#!/usr/bin/env python3
import sys
import os
import shutil
import subprocess
import threading
from pathlib import Path
from datetime import datetime
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                            QHBoxLayout, QToolBar, QStatusBar, QLineEdit, QLabel, 
                            QMessageBox, QInputDialog, QFileDialog, QMenu,
                            QAbstractItemView, QHeaderView, QTabWidget,
                            QToolButton, QComboBox, QStyleFactory, QDialog,
                            QDialogButtonBox, QFormLayout, QCheckBox, QGroupBox,
                            QFileSystemModel, QAction, QSizePolicy, QMenuBar,
                            QListWidget, QListWidgetItem, QProgressDialog,
                            QProgressBar, QDockWidget, QFrame, QTreeView, QListView, QSplitter, QSlider, QButtonGroup)
from PyQt5.QtCore import QDir, QModelIndex, Qt, QSortFilterProxyModel, pyqtSignal, QSize, QThread, QMimeData, QTimer, QSettings, QUrl, QPoint
from PyQt5.QtGui import QIcon, QKeySequence, QPalette, QColor, QFont, QPixmap, QDrag, QPainter, QClipboard
import platform
import psutil
import getpass
import time
import json
import stat
import urllib.parse

# =============================================================================
# COLOR THEMES
# =============================================================================
COLOR_THEMES = {
    'Cyberpunk': {
        'bg': '#0a0a0f',
        'fg': '#00ff9f',
        'accent': '#0080ff',
        'accent_hover': '#00ff9f',
        'surface': '#1a1a2f',
        'secondary': '#2a2a3f',
        'text_primary': '#00ff9f',
        'text_secondary': '#0080ff',
        'warning': '#ff0040',
        'danger': '#ff0040',
        'success': '#00ff9f',
        'border': '#0080ff',
        'highlight': '#0080ff'
    },
    'Dark': {
        'bg': '#1e1e2e',
        'fg': '#cdd6f4',
        'accent': '#89b4fa',
        'accent_hover': '#74c7ec',
        'surface': '#313244',
        'secondary': '#45475a',
        'text_primary': '#cdd6f4',
        'text_secondary': '#a6adc8',
        'warning': '#f9e2af',
        'danger': '#f38ba8',
        'success': '#a6e3a1',
        'border': '#585b70',
        'highlight': '#89b4fa'
    },
    'Nord': {
        'bg': '#2e3440',
        'fg': '#d8dee9',
        'accent': '#5e81ac',
        'accent_hover': '#81a1c1',
        'surface': '#3b4252',
        'secondary': '#434c5e',
        'text_primary': '#e5e9f0',
        'text_secondary': '#d8dee9',
        'warning': '#ebcb8b',
        'danger': '#bf616a',
        'success': '#a3be8c',
        'border': '#4c566a',
        'highlight': '#5e81ac'
    },
    'Gruvbox': {
        'bg': '#282828',
        'fg': '#ebdbb2',
        'accent': '#fe8019',
        'accent_hover': '#d65d0e',
        'surface': '#3c3836',
        'secondary': '#504945',
        'text_primary': '#ebdbb2',
        'text_secondary': '#d5c4a1',
        'warning': '#fabd2f',
        'danger': '#fb4934',
        'success': '#b8bb26',
        'border': '#665c54',
        'highlight': '#fe8019'
    },
    'Tokyo Night': {
        'bg': '#15161E',
        'fg': '#c0caf5',
        'accent': '#7aa2f7',
        'accent_hover': '#89ddff',
        'surface': '#1a1b26',
        'secondary': '#2f334d',
        'text_primary': '#c0caf5',
        'text_secondary': '#a9b1d6',
        'warning': '#e0af68',
        'danger': '#f7768e',
        'success': '#9ece6a',
        'border': '#414868',
        'highlight': '#7aa2f7'
    },
    'Synthwave': {
        'bg': '#2b213a',
        'fg': '#f4eee4',
        'accent': '#ff4e8b',
        'accent_hover': '#ff7edb',
        'surface': '#3b2a4a',
        'secondary': '#4a385a',
        'text_primary': '#f4eee4',
        'text_secondary': '#d9c8b8',
        'warning': '#f9a875',
        'danger': '#ff4e8b',
        'success': '#72f1b8',
        'border': '#554971',
        'highlight': '#ff4e8b'
    },
    'Matrix': {
        'bg': '#001100',
        'fg': '#00ff00',
        'accent': '#00ff00',
        'accent_hover': '#44ff44',
        'surface': '#002200',
        'secondary': '#003300',
        'text_primary': '#00ff00',
        'text_secondary': '#00cc00',
        'warning': '#ffff00',
        'danger': '#ff0000',
        'success': '#00ff00',
        'border': '#004400',
        'highlight': '#00ff00'
    },
    'Solarized Dark': {
        'bg': '#002b36',
        'fg': '#839496',
        'accent': '#268bd2',
        'accent_hover': '#6c71c4',
        'surface': '#073642',
        'secondary': '#586e75',
        'text_primary': '#93a1a1',
        'text_secondary': '#657b83',
        'warning': '#b58900',
        'danger': '#dc322f',
        'success': '#859900',
        'border': '#073642',
        'highlight': '#268bd2'
    },
    'Dracula': {
        'bg': '#282a36',
        'fg': '#f8f8f2',
        'accent': '#bd93f9',
        'accent_hover': '#ff79c6',
        'surface': '#44475a',
        'secondary': '#6272a4',
        'text_primary': '#f8f8f2',
        'text_secondary': '#6272a4',
        'warning': '#f1fa8c',
        'danger': '#ff5555',
        'success': '#50fa7b',
        'border': '#44475a',
        'highlight': '#bd93f9'
    },
    'One Dark': {
        'bg': '#282c34',
        'fg': '#abb2bf',
        'accent': '#61afef',
        'accent_hover': '#56b6c2',
        'surface': '#353b45',
        'secondary': '#3e4451',
        'text_primary': '#abb2bf',
        'text_secondary': '#5c6370',
        'warning': '#e5c07b',
        'danger': '#e06c75',
        'success': '#98c379',
        'border': '#3e4451',
        'highlight': '#61afef'
    }
}

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

def check_mount_dependencies():
    """Check if required mounting tools are available"""
    tools = ['udisksctl', 'mount', 'umount', 'lsblk']
    missing = []
    
    for tool in tools:
        if not shutil.which(tool):
            missing.append(tool)
            
    if missing:
        print(f"Warning: Missing tools: {missing}")
        print("USB auto-mounting may not work properly")
        return False
    else:
        print("All required mounting tools are available")
        return True

def handle_url_scheme(url):
    """Handle file:// and trash:// URLs from browsers"""
    if url.startswith('file://'):
        # Convert file URL to local path
        from urllib.parse import unquote
        path = unquote(url[7:])  # Remove 'file://' prefix
        return path
    elif url.startswith('trash:///'):
        # Handle trash:/// URI scheme
        return 'trash:///'
    return None

def detect_launch_intent():
    """Detect how the application was launched and what to open"""
    # Check command line arguments
    for arg in sys.argv[1:]:
        if arg.startswith('trash:///'):
            return 'trash:///'
        elif arg.startswith('file://'):
            return handle_url_scheme(arg)
        elif os.path.isdir(arg):
            return arg
    
    # Check environment variables for desktop launches
    desktop_session = os.environ.get('DESKTOP_SESSION', '').lower()
    xdg_current_desktop = os.environ.get('XDG_CURRENT_DESKTOP', '').lower()
    
    # If launched from desktop with no specific target, open home directory
    if 'DISPLAY' in os.environ and os.environ.get('DISPLAY'):
        print(f"Desktop launch detected: {desktop_session} / {xdg_current_desktop}")
        return os.path.expanduser('~')
    
    # Default to current directory
    return os.getcwd()


# =============================================================================
# THREAD MONITOR
# =============================================================================

class ThreadMonitor:
    """Monitor thread health and prevent leaks"""
    def __init__(self):
        self.active_threads = []
        self._lock = threading.Lock()

    def register_thread(self, thread, name):
        with self._lock:
            self.active_threads.append((thread, name, time.time()))

    def unregister_thread(self, thread):
        with self._lock:
            self.active_threads = [(t, n, st) for t, n, st in self.active_threads if t != thread]

    def cleanup_stale_threads(self):
        current_time = time.time()
        stale_threads = []
        with self._lock:
            for thread, name, start_time in self.active_threads:
                if not thread.isRunning():
                    stale_threads.append((thread, name))
                elif current_time - start_time > 3600:  # 1 hour timeout
                    print(f"Warning: Thread {name} running for over 1 hour")
            for thread, name in stale_threads:
                self.active_threads = [(t, n, st) for t, n, st in self.active_threads if t != thread]

    def get_active_count(self):
        with self._lock:
            return len(self.active_threads)

# =============================================================================
# SETTINGS MANAGER
# =============================================================================

class SettingsManager:
    """Manages application settings persistence"""
    def __init__(self):
        self.settings = QSettings("EcoFileManager", "EcoFileManager")

    def save_window_state(self, window):
        """Save window geometry and state"""
        self.settings.setValue("geometry", window.saveGeometry())
        self.settings.setValue("windowState", window.saveState())
        self.settings.setValue("iconSize", window.icon_size)
        self.settings.setValue("showHidden", window.show_hidden)
        self.settings.setValue("theme", window.current_theme)

    def load_window_state(self, window):
        """Load window geometry and state"""
        geometry = self.settings.value("geometry")
        if geometry:
            window.restoreGeometry(geometry)
        state = self.settings.value("windowState")
        if state:
            window.restoreState(state)
        # Load icon size
        icon_size = self.settings.value("iconSize", 32, type=int)
        window.icon_size = icon_size
        window.update_icon_size(icon_size)
        # Load show hidden files setting
        show_hidden = self.settings.value("showHidden", False, type=bool)
        window.show_hidden = show_hidden
        # Load theme
        theme = self.settings.value("theme", "Cyberpunk")
        window.current_theme = theme
        window.apply_theme(theme)

    def get_default_terminal(self):
        """Get user's default terminal preference"""
        return self.settings.value("defaultTerminal", "", type=str)

    def set_default_terminal(self, terminal):
        """Set user's default terminal preference"""
        self.settings.setValue("defaultTerminal", terminal)

# =============================================================================
# FILE OPERATION THREAD
# =============================================================================

class FileOperationThread(QThread):
    progress = pyqtSignal(int)
    message = pyqtSignal(str)
    finished_success = pyqtSignal()
    error_occurred = pyqtSignal(str)
    cancelled_signal = pyqtSignal()

    def __init__(self, operation_type, source_paths, destination_dir, parent=None):
        super().__init__(parent)
        self.operation_type = operation_type
        self.source_paths = source_paths
        self.destination_dir = destination_dir
        self.cancelled = False
        self._lock = threading.Lock()

    def cancel(self):
        """Thread-safe cancellation"""
        with self._lock:
            self.cancelled = True

    def is_cancelled(self):
        """Thread-safe cancellation check"""
        with self._lock:
            return self.cancelled

    def run(self):
        try:
            total_files = self.count_total_files()
            processed_files = 0
            for source_path in self.source_paths:
                if self.is_cancelled():
                    break
                dest_path = os.path.join(self.destination_dir, os.path.basename(source_path))
                if self.operation_type == 'copy':
                    if not self.copy_item(source_path, dest_path, total_files, processed_files):
                        break
                elif self.operation_type == 'move':
                    if not self.move_item(source_path, dest_path, total_files, processed_files):
                        break
            if not self.is_cancelled():
                self.finished_success.emit()
            else:
                self.cancelled_signal.emit()
                self.message.emit("Operation cancelled")
        except Exception as e:
            self.error_occurred.emit(str(e))

    def count_total_files(self):
        total = 0
        for path in self.source_paths:
            if self.is_cancelled():
                return 0
            if os.path.isfile(path):
                total += 1
            else:
                for root, dirs, files in os.walk(path):
                    if self.is_cancelled():
                        return 0
                    total += len(files)
                    # Allow UI updates during counting
                    if total % 100 == 0:
                        QApplication.processEvents()
        return total

    def copy_item(self, src, dst, total_files, processed_files):
        if self.is_cancelled():
            return False
        if os.path.isfile(src):
            self.message.emit(f"Copying {os.path.basename(src)}")
            if not self.safe_copy_file(src, dst):
                return False
            processed_files += 1
            progress = int((processed_files / total_files) * 100) if total_files > 0 else 0
            self.progress.emit(progress)
            # Allow UI updates every 10 files
            if processed_files % 10 == 0:
                QApplication.processEvents()
        else:
            if not os.path.exists(dst):
                os.makedirs(dst)
            for item in os.listdir(src):
                if self.is_cancelled():
                    return False
                src_path = os.path.join(src, item)
                dst_path = os.path.join(dst, item)
                if not self.copy_item(src_path, dst_path, total_files, processed_files):
                    return False
        return True

    def move_item(self, src, dst, total_files, processed_files):
        if self.is_cancelled():
            return False
        self.message.emit(f"Moving {os.path.basename(src)}")
        if not self.safe_move(src, dst):
            return False
        processed_files += 1
        progress = int((processed_files / total_files) * 100) if total_files > 0 else 0
        self.progress.emit(progress)
        # Allow UI updates
        if processed_files % 10 == 0:
            QApplication.processEvents()
        return True

    def safe_copy_file(self, src, dst):
        if self.is_cancelled():
            return False
        
        # Check if destination file exists
        if os.path.exists(dst):
            # File conflict - we need to handle this
            # For now, we'll auto-rename to avoid overwriting
            base, ext = os.path.splitext(dst)
            counter = 1
            while os.path.exists(f"{base} ({counter}){ext}"):
                if self.is_cancelled():
                    return False
                counter += 1
            dst = f"{base} ({counter}){ext}"
            
        try:
            shutil.copy2(src, dst)
            return True
        except Exception as e:
            self.error_occurred.emit(f"Failed to copy {src}: {str(e)}")
            return False

    def safe_move(self, src, dst):
        if self.is_cancelled():
            return False

        # Use realpath to resolve symlinks and normalize paths
        src_real = os.path.realpath(src)
        dst_real = os.path.realpath(dst)

        # Skip if source and destination resolve to the same file/directory
        if src_real == dst_real:
            return True  # Nothing to do

        # Check if source exists
        if not os.path.exists(src_real):
            return False

        # Prevent moving a directory into itself
        if os.path.isdir(src_real):
            src_norm = os.path.normpath(src_real)
            dst_norm = os.path.normpath(dst_real)
            if dst_norm.startswith(src_norm + os.sep):
                self.error_occurred.emit(f"Cannot move directory into itself: {src}")
                return False

        # Handle destination conflict by auto-renaming
        if os.path.exists(dst):
            base, ext = os.path.splitext(dst)
            counter = 1
            while os.path.exists(f"{base} ({counter}){ext}"):
                if self.is_cancelled():
                    return False
                counter += 1
            dst = f"{base} ({counter}){ext}"

        try:
            src_stat = os.stat(src)
            dst_parent = os.path.dirname(dst)
            if os.path.exists(dst_parent):
                dst_stat = os.stat(dst_parent)
                if src_stat.st_dev == dst_stat.st_dev:
                    os.rename(src, dst)  # Same filesystem
                else:
                    shutil.move(src, dst)  # Cross-filesystem
            else:
                shutil.move(src, dst)
            return True
        except Exception as e:
            self.error_occurred.emit(f"Failed to move {src}: {str(e)}")
            return False


# =============================================================================
# THUMBNAIL GENERATOR
# =============================================================================

class ThumbnailGenerator:
    @staticmethod
    def generate_video_thumbnail(video_path, thumbnail_path, size=256):
        """Generate thumbnail for video using ffmpegthumbnailer"""
        try:
            cmd = [
                'ffmpegthumbnailer',
                '-i', video_path,
                '-o', thumbnail_path,
                '-s', str(size),
                '-q', '10'
            ]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            return result.returncode == 0
        except (subprocess.TimeoutExpired, subprocess.CalledProcessError, FileNotFoundError):
            return False

    @staticmethod
    def generate_image_thumbnail(image_path, thumbnail_path, size=256):
        """Generate thumbnail for image"""
        try:
            pixmap = QPixmap(image_path)
            if not pixmap.isNull():
                # Scale the image to create thumbnail
                scaled_pixmap = pixmap.scaled(size, size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                return scaled_pixmap.save(thumbnail_path)
            return False
        except Exception:
            return False

# =============================================================================
# SORTABLE FILE SYSTEM MODEL
# =============================================================================

# =============================================================================
# SORTABLE FILE SYSTEM MODEL
# =============================================================================

# =============================================================================
# SORTABLE FILE SYSTEM MODEL
# =============================================================================

class SortableFileSystemModel(QFileSystemModel):
    """Enhanced QFileSystemModel with better sorting capabilities"""
    
    def __init__(self, show_hidden=False):
        # Call parent __init__ FIRST
        super().__init__()
        
        # Now initialize your custom properties
        self.thumbnail_cache = {}
        self.thumbnail_dir = os.path.expanduser('~/.cache/eco-filemanager/thumbnails')
        os.makedirs(self.thumbnail_dir, exist_ok=True)
        self.show_hidden = show_hidden
        self.max_cache_size = 500
        self.cache_hits = 0
        self.cache_misses = 0
        
        # Cleanup timer for cache management
        self.cleanup_timer = QTimer()
        self.cleanup_timer.timeout.connect(self.cleanup_cache)
        self.cleanup_timer.start(30000)

    def cleanup_cache(self):
        """Clean up thumbnail cache to prevent memory leaks"""
        if len(self.thumbnail_cache) > self.max_cache_size:
            keys_to_remove = list(self.thumbnail_cache.keys())[:len(self.thumbnail_cache) - self.max_cache_size]
            for key in keys_to_remove:
                del self.thumbnail_cache[key]

    def data(self, index, role=Qt.DisplayRole):
        # Handle thumbnails for decoration role in first column only
        if role == Qt.DecorationRole and index.column() == 0:
            file_path = self.filePath(index)
            if self.should_generate_thumbnail(file_path):
                thumbnail = self.get_thumbnail(file_path)
                if thumbnail:
                    return thumbnail
        # For all other cases, use the parent implementation
        return super().data(index, role)

    def should_generate_thumbnail(self, file_path):
        if os.path.isdir(file_path):
            return False
        video_extensions = {'.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v', '.3gp'}
        image_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp', '.svg'}
        ext = os.path.splitext(file_path)[1].lower()
        return ext in video_extensions.union(image_extensions)

    def get_thumbnail(self, file_path):
        # Check cache first
        if file_path in self.thumbnail_cache and len(self.thumbnail_cache) < self.max_cache_size:
            self.cache_hits += 1
            return self.thumbnail_cache[file_path]
        self.cache_misses += 1
        
        # Generate thumbnail path
        file_hash = str(hash(file_path))
        thumbnail_path = os.path.join(self.thumbnail_dir, f"{file_hash}.png")
        
        # Check if thumbnail exists and is recent
        if os.path.exists(thumbnail_path):
            file_mtime = os.path.getmtime(file_path)
            thumb_mtime = os.path.getmtime(thumbnail_path)
            if thumb_mtime >= file_mtime:
                icon = QIcon(thumbnail_path)
                self.thumbnail_cache[file_path] = icon
                return icon
        
        # Generate new thumbnail
        ext = os.path.splitext(file_path)[1].lower()
        success = False
        if ext in {'.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v', '.3gp'}:
            success = ThumbnailGenerator.generate_video_thumbnail(file_path, thumbnail_path)
        elif ext in {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp'}:
            success = ThumbnailGenerator.generate_image_thumbnail(file_path, thumbnail_path)
        
        if success and os.path.exists(thumbnail_path):
            icon = QIcon(thumbnail_path)
            self.thumbnail_cache[file_path] = icon
            return icon
        
        return None


# =============================================================================
# SORTABLE TREE VIEW
# =============================================================================

# =============================================================================
# SORTABLE TREE VIEW
# =============================================================================

class SortableTreeView(QTreeView):
    """Tree view with enhanced column sorting"""
    file_dropped = pyqtSignal(list, str, str)
    drag_cut_completed = pyqtSignal(list)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setDragEnabled(True)
        self.setDropIndicatorShown(True)
        self.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.setDragDropMode(QAbstractItemView.DragDrop)
        self.is_cut_operation = False
        
        # Enable sorting
        self.setSortingEnabled(True)
        
        # Set up column header to be clickable for sorting
        header = self.header()
        header.setSectionsClickable(True)
        header.setSortIndicatorShown(True)
        header.setStretchLastSection(False)
        header.setDefaultSectionSize(150)
        header.setSectionResizeMode(QHeaderView.Interactive)

    def startDrag(self, supportedActions):
        indexes = self.selectedIndexes()
        if not indexes:
            return
        
        main_window = self.window()
        if main_window:
            main_window.raise_()
        
        modifiers = QApplication.keyboardModifiers()
        self.is_cut_operation = bool(modifiers & Qt.AltModifier)
        
        drag = QDrag(self)
        mime_data = QMimeData()
        
        file_paths = []
        model = self.model()
        for index in indexes:
            if index.column() == 0:
                file_path = model.filePath(index)
                file_paths.append(file_path)
        
        mime_data.setUrls([QUrl.fromLocalFile(path) for path in file_paths])
        
        if self.is_cut_operation:
            gnome_format = "cut\n" + '\n'.join([f"file://{path}" for path in file_paths])
        else:
            gnome_format = "copy\n" + '\n'.join([f"file://{path}" for path in file_paths])
        
        mime_data.setData("x-special/gnome-copied-files", gnome_format.encode('utf-8'))
        mime_data.setData("text/uri-list", '\n'.join([f"file://{path}" for path in file_paths]).encode('utf-8'))
        mime_data.setText('\n'.join(file_paths))
        
        drag.setMimeData(mime_data)
        
        if len(file_paths) == 1:
            icon = model.data(indexes[0], Qt.DecorationRole)
            if icon:
                pixmap = icon.pixmap(32, 32)
                drag.setPixmap(pixmap)
        
        if self.is_cut_operation:
            action = drag.exec_(Qt.MoveAction | Qt.CopyAction, Qt.MoveAction)
        else:
            action = drag.exec_(Qt.MoveAction | Qt.CopyAction, Qt.CopyAction)
            
        if self.is_cut_operation and action == Qt.MoveAction:
            self.drag_cut_completed.emit(file_paths)

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
            self.window().raise_()
        else:
            event.ignore()

    def dragMoveEvent(self, event):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
            self.window().raise_()
        else:
            event.ignore()

    def dropEvent(self, event):
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            file_paths = [url.toLocalFile() for url in urls]
            
            index = self.indexAt(event.pos())
            
            if index.isValid():
                model = self.model()
                item_path = model.filePath(index)
                
                if os.path.isfile(item_path):
                    destination_dir = os.path.dirname(item_path)
                else:
                    destination_dir = item_path
                    
                    for file_path in file_paths:
                        if os.path.abspath(file_path) == os.path.abspath(item_path):
                            destination_dir = os.path.dirname(item_path)
                            break
            else:
                destination_dir = self.model().rootPath()
            
            operation = 'copy'
            
            mime_data = event.mimeData()
            if mime_data.hasFormat("x-special/gnome-copied-files"):
                data = mime_data.data("x-special/gnome-copied-files").data().decode('utf-8')
                if data.startswith("cut\n"):
                    operation = 'move'
                elif data.startswith("copy\n"):
                    operation = 'copy'
            elif event.keyboardModifiers() & Qt.ShiftModifier:
                operation = 'move'
            elif event.keyboardModifiers() & Qt.ControlModifier:
                operation = 'copy'
            
            self.file_dropped.emit(file_paths, destination_dir, operation)
            
            event.acceptProposedAction()
        else:
            event.ignore()

# =============================================================================
# AUTO MOUNTER
# =============================================================================

class AutoMounter(QThread):
    """Thread for automatically mounting USB devices"""
    mount_success = pyqtSignal(str, str)
    mount_failed = pyqtSignal(str, str)
    unmount_success = pyqtSignal(str)
    unmount_failed = pyqtSignal(str, str)
    
    def __init__(self):
        super().__init__()
        self.running = True
        self.mount_queue = []
        self.unmount_queue = []
        self.username = getpass.getuser()
        self.uid = os.getuid()
        self.gid = os.getgid()
        self._lock = threading.Lock()
        self.mounted_devices = {}
        
    def run(self):
        while self.running:
            try:
                with self._lock:
                    current_mount_queue = self.mount_queue.copy()
                    self.mount_queue.clear()
                    current_unmount_queue = self.unmount_queue.copy()
                    self.unmount_queue.clear()
                
                for device in current_mount_queue:
                    if not self.running:
                        break
                    print(f"üîÑ AutoMounter: Processing device {device}")
                    self.try_mount_device(device)
                
                for mount_point in current_unmount_queue:
                    if not self.running:
                        break
                    self.try_unmount_device(mount_point)
                    
                time.sleep(2)
            except Exception as e:
                print(f"‚ùå AutoMounter error: {e}")
                time.sleep(5)

    def add_device(self, device):
        with self._lock:
            if device not in self.mount_queue:
                print(f"üì• AutoMounter: Queuing device for mount: {device}")
                self.mount_queue.append(device)

    def debug_mount_issue(self, device):
        print(f"üîç Debugging mount issue for {device}:")
        
        if not os.path.exists(device):
            print(f"  ‚ùå Device {device} does not exist")
            return False
            
        try:
            stat_info = os.stat(device)
            print(f"  ‚úÖ Device exists, permissions: {oct(stat_info.st_mode)}")
            print(f"  üìä Device owner: {stat_info.st_uid} (current user: {self.uid})")
        except Exception as e:
            print(f"  ‚ùå Cannot access device: {e}")
            return False
            
        try:
            result = subprocess.run(['blkid', device], capture_output=True, text=True)
            if result.returncode == 0:
                print(f"  üíæ Filesystem info: {result.stdout.strip()}")
            else:
                print(f"  ‚ùå Cannot determine filesystem: {result.stderr}")
        except Exception as e:
            print(f"  ‚ùå blkid failed: {e}")
            
        try:
            result = subprocess.run(['findmnt', device], capture_output=True, text=True)
            if result.returncode == 0:
                print(f"  ‚úÖ Already mounted: {result.stdout}")
            else:
                print("  üìå Not currently mounted")
        except Exception as e:
            print(f"  ‚ùå findmnt failed: {e}")
            
        try:
            result = subprocess.run(['udisksctl', 'info', '-b', device], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                print(f"  ‚ÑπÔ∏è UDisks2 info:")
                for line in result.stdout.split('\n'):
                    if any(key in line for key in ['MountPoints', 'IdType', 'IdUsage', 'HintAuto']):
                        print(f"    {line.strip()}")
            else:
                print(f"  ‚ùå UDisks2 info failed: {result.stderr}")
        except Exception as e:
            print(f"  ‚ùå udisksctl info failed: {e}")
            
        return True

    def try_mount_device(self, device):
        if platform.system() != "Linux":
            return
            
        print(f"üöÄ AutoMounter: Attempting to mount {device}")
        
        if not self.debug_mount_issue(device):
            self.mount_failed.emit(device, "Device not accessible")
            return
        
        mount_point = self.get_existing_mount_point(device)
        if mount_point:
            print(f"‚úÖ AutoMounter: {device} already mounted at {mount_point}")
            self.mount_success.emit(device, mount_point)
            return
            
        print("üîÑ Trying mount methods...")
        
        if self.try_udisks_mount(device):
            return
            
        if self.try_gio_mount(device):
            return
            
        if self.try_dbus_mount(device):
            return
            
        if self.try_pmount(device):
            return
            
        if self.try_direct_mount(device):
            return
            
        if self.try_mount_with_fstype(device):
            return
            
        error_msg = "All mount methods failed. Check console for detailed debug info."
        print(f"‚ùå {error_msg}")
        self.mount_failed.emit(device, error_msg)

    def get_existing_mount_point(self, device):
        try:
            result = subprocess.run(
                ['findmnt', '-n', '-o', 'TARGET', '-S', device],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0 and result.stdout.strip():
                mount_point = result.stdout.strip()
                print(f"üìç Found existing mount point: {mount_point}")
                return mount_point
                
            with open('/proc/mounts', 'r') as f:
                for line in f:
                    if device in line:
                        parts = line.split()
                        if len(parts) > 1:
                            mount_point = parts[1]
                            print(f"üìç Found in /proc/mounts: {mount_point}")
                            return mount_point
        except Exception as e:
            print(f"‚ùå Error checking existing mounts: {e}")
        return None

    def try_udisks_mount(self, device):
        try:
            print(f"üîß Method 1: Trying udisks2 mount for {device}")
            
            result = subprocess.run(
                ['udisksctl', 'mount', '-b', device],
                capture_output=True, text=True, timeout=15
            )
            
            print(f"üì§ udisksctl stdout: {result.stdout}")
            print(f"üì• udisksctl stderr: {result.stderr}")
            print(f"üî¢ udisksctl return code: {result.returncode}")
            
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'mounted at' in line:
                        mount_point = line.split('mounted at')[-1].strip().rstrip('.')
                        print(f"‚úÖ Udisks2 mounted {device} at {mount_point}")
                        self.mount_success.emit(device, mount_point)
                        return True
                        
                if 'at ' in result.stdout:
                    parts = result.stdout.split('at ')
                    if len(parts) > 1:
                        mount_point = parts[1].strip().rstrip('.')
                        print(f"‚úÖ Udisks2 mounted {device} at {mount_point}")
                        self.mount_success.emit(device, mount_point)
                        return True
            else:
                print(f"‚ùå Udisks2 mount failed with return code {result.returncode}")
                
        except subprocess.TimeoutExpired:
            print(f"‚è∞ udisksctl timeout for {device}")
        except Exception as e:
            print(f"üí• udisksctl exception: {e}")
            
        return False

    def try_gio_mount(self, device):
        try:
            print(f"üîß Method 2: Trying gio mount for {device}")
            
            device_uri = f"file://{device}"
            
            result = subprocess.run(
                ['gio', 'mount', '-d', device_uri],
                capture_output=True, text=True, timeout=15
            )
            
            print(f"üì§ gio stdout: {result.stdout}")
            print(f"üì• gio stderr: {result.stderr}")
            
            if result.returncode == 0:
                mount_point = self.find_gio_mount_point(device)
                if mount_point:
                    print(f"‚úÖ Gio mounted {device} at {mount_point}")
                    self.mount_success.emit(device, mount_point)
                    return True
                else:
                    print("‚ùå Gio mount succeeded but couldn't find mount point")
            else:
                print(f"‚ùå Gio mount failed with return code {result.returncode}")
                    
        except FileNotFoundError:
            print("‚ùå gio command not found")
        except Exception as e:
            print(f"üí• gio mount failed: {e}")
            
        return False

    def find_gio_mount_point(self, device):
        try:
            result = subprocess.run(
                ['gio', 'mount', '-l'],
                capture_output=True, text=True, timeout=10
            )
            
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if device in line:
                        print(f"üîç Found in gio mount -l: {line}")
                        if '->' in line:
                            parts = line.split('->')
                            if len(parts) > 1:
                                mount_point = parts[1].strip()
                                if mount_point.startswith('file://'):
                                    mount_point = mount_point[7:]
                                return mount_point
                                
            standard_locations = [
                f"/run/media/{self.username}",
                f"/media/{self.username}",
                "/media",
                "/mnt"
            ]
            
            for location in standard_locations:
                if os.path.exists(location):
                    print(f"üîç Checking location: {location}")
                    for item in os.listdir(location):
                        full_path = os.path.join(location, item)
                        if os.path.ismount(full_path):
                            try:
                                result = subprocess.run(
                                    ['findmnt', '-n', '-o', 'SOURCE', full_path],
                                    capture_output=True, text=True
                                )
                                if result.returncode == 0 and device in result.stdout:
                                    print(f"‚úÖ Found matching mount point: {full_path}")
                                    return full_path
                            except:
                                pass
                                
        except Exception as e:
            print(f"üí• Error finding gio mount point: {e}")
            
        return None

    def try_dbus_mount(self, device):
        try:
            print(f"üîß Method 3: Trying DBus mount for {device}")
            
            try:
                import dbus
                print("‚úÖ dbus module available")
                
                bus = dbus.SystemBus()
                udisks = dbus.Interface(
                    bus.get_object('org.freedesktop.UDisks2', '/org/freedesktop/UDisks2'),
                    'org.freedesktop.DBus.ObjectManager'
                )
                
                objects = udisks.GetManagedObjects()
                for obj_path, interfaces in objects.items():
                    if 'org.freedesktop.UDisks2.Block' in interfaces:
                        block = interfaces['org.freedesktop.UDisks2.Block']
                        device_prop = block.get('Device', '')
                        if str(device_prop) == device:
                            print(f"‚úÖ Found device in DBus: {obj_path}")
                            block_obj = bus.get_object('org.freedesktop.UDisks2', obj_path)
                            filesystem = dbus.Interface(block_obj, 'org.freedesktop.UDisks2.Filesystem')
                            
                            options = dbus.Dictionary({
                                'auth.no_user_interaction': True
                            }, signature='sv')
                            
                            mount_point = filesystem.Mount(options)
                            print(f"‚úÖ DBus mounted {device} at {mount_point}")
                            self.mount_success.emit(device, mount_point)
                            return True
                            
            except ImportError:
                print("‚ùå dbus module not available")
            except Exception as e:
                print(f"üí• DBus mount failed: {e}")
                
        except Exception as e:
            print(f"üí• DBus mount exception: {e}")
            
        return False

    def try_pmount(self, device):
        try:
            print(f"üîß Method 4: Trying pmount for {device}")
            
            result = subprocess.run(
                ['pmount', device],
                capture_output=True, text=True
            )
            
            print(f"üì§ pmount stdout: {result.stdout}")
            print(f"üì• pmount stderr: {result.stderr}")
            
            if result.returncode == 0:
                mount_point = f"/media/{os.path.basename(device)}"
                if os.path.ismount(mount_point):
                    print(f"‚úÖ pmount successful at {mount_point}")
                    self.mount_success.emit(device, mount_point)
                    return True
                else:
                    print(f"‚ùå pmount succeeded but {mount_point} is not a mount point")
                    
        except FileNotFoundError:
            print("‚ùå pmount not installed")
        except Exception as e:
            print(f"üí• pmount failed: {e}")
            
        return False

    def try_direct_mount(self, device):
        try:
            print(f"üîß Method 5: Trying direct mount for {device}")
            
            mount_point = f"/media/{os.path.basename(device)}"
            os.makedirs(mount_point, exist_ok=True)
            
            result = subprocess.run(
                ['mount', device, mount_point],
                capture_output=True, text=True
            )
            
            print(f"üì§ mount stdout: {result.stdout}")
            print(f"üì• mount stderr: {result.stderr}")
            
            if result.returncode == 0:
                if os.path.ismount(mount_point):
                    print(f"‚úÖ Direct mount successful at {mount_point}")
                    self.mount_success.emit(device, mount_point)
                    return True
                else:
                    print(f"‚ùå mount succeeded but {mount_point} is not a mount point")
            else:
                print(f"‚ùå Direct mount failed with return code {result.returncode}")
                try:
                    if not os.path.ismount(mount_point):
                        os.rmdir(mount_point)
                except:
                    pass
                    
        except Exception as e:
            print(f"üí• Direct mount exception: {e}")
            
        return False

    def try_mount_with_fstype(self, device):
        try:
            print(f"üîß Method 6: Trying mount with explicit filesystem type for {device}")
            
            result = subprocess.run(['blkid', '-s', 'TYPE', '-o', 'value', device], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                fstype = result.stdout.strip()
                print(f"üìã Detected filesystem type: {fstype}")
                
                if fstype:
                    mount_point = f"/media/{os.path.basename(device)}"
                    os.makedirs(mount_point, exist_ok=True)
                    
                    cmd = ['mount', '-t', fstype, device, mount_point]
                    result = subprocess.run(cmd, capture_output=True, text=True)
                    
                    print(f"üì§ mount -t {fstype} stdout: {result.stdout}")
                    print(f"üì• mount -t {fstype} stderr: {result.stderr}")
                    
                    if result.returncode == 0 and os.path.ismount(mount_point):
                        print(f"‚úÖ Mount with filesystem type {fstype} successful at {mount_point}")
                        self.mount_success.emit(device, mount_point)
                        return True
                    else:
                        try:
                            if not os.path.ismount(mount_point):
                                os.rmdir(mount_point)
                        except:
                            pass
            else:
                print("‚ùå Could not detect filesystem type")
                
        except Exception as e:
            print(f"üí• Mount with filesystem type failed: {e}")
            
        return False

    def try_unmount_device(self, mount_point):
        try:
            print(f"üîß Trying to unmount {mount_point}")
            
            result = subprocess.run(
                ['udisksctl', 'unmount', '-m', mount_point],
                capture_output=True, text=True, timeout=10
            )
            if result.returncode == 0:
                print(f"‚úÖ Udisks2 unmount successful")
                self.unmount_success.emit(mount_point)
                return
                
            result = subprocess.run(
                ['gio', 'mount', '-u', f"file://{mount_point}"],
                capture_output=True, text=True, timeout=10
            )
            if result.returncode == 0:
                print(f"‚úÖ Gio unmount successful")
                self.unmount_success.emit(mount_point)
                return
                
            result = subprocess.run(
                ['umount', mount_point],
                capture_output=True, text=True, timeout=10
            )
            if result.returncode == 0:
                print(f"‚úÖ Direct unmount successful")
                self.unmount_success.emit(mount_point)
                return
                
            error_msg = f"Unmount failed: {result.stderr}"
            print(f"‚ùå {error_msg}")
            self.unmount_failed.emit(mount_point, error_msg)
            
        except Exception as e:
            error_msg = f"Unmount exception: {str(e)}"
            print(f"‚ùå {error_msg}")
            self.unmount_failed.emit(mount_point, error_msg)

    def stop(self):
        self.running = False


# =============================================================================
# USB MONITOR
# =============================================================================

class USBMonitor(QThread):
    """Improved USB monitoring with reliable device detection"""
    usb_detected = pyqtSignal(list)
    device_removed = pyqtSignal(str)
    status_message = pyqtSignal(str)
    mount_success = pyqtSignal(str, str)
    
    def __init__(self):
        super().__init__()
        self.running = True
        self.last_devices = set()
        self.auto_mounter = AutoMounter()
        self.auto_mounter.mount_success.connect(self.on_mount_success)
        self.auto_mounter.mount_failed.connect(self.on_mount_failed)
        self.auto_mounter.start()

    def run(self):
        print("USBMonitor: Starting USB monitoring...")
        
        self.scan_devices()
        
        while self.running:
            try:
                self.scan_devices()
                time.sleep(2)
            except Exception as e:
                print(f"USBMonitor error: {e}")
                time.sleep(5)

    def scan_devices(self):
        try:
            current_devices = self.get_usb_devices()
            mounted_devices = self.get_mounted_filesystems()
            
            all_devices = current_devices.union(mounted_devices)
            
            new_devices = all_devices - self.last_devices
            removed_devices = self.last_devices - all_devices
            
            for device in new_devices:
                if device.startswith('/dev/') and self.is_actual_usb_device(device):
                    print(f"USBMonitor: New USB device detected: {device}")
                    self.status_message.emit(f"Detected USB device: {os.path.basename(device)}")
                    self.auto_mounter.add_device(device)
                elif not device.startswith('/dev/'):
                    print(f"USBMonitor: New mount point detected: {device}")
                    
            for device in removed_devices:
                print(f"USBMonitor: Device removed: {device}")
                self.status_message.emit(f"Device removed: {os.path.basename(device)}")
                self.device_removed.emit(device)
            
            if new_devices or removed_devices:
                print(f"USBMonitor: Emitting {len(all_devices)} devices")
                self.usb_detected.emit(list(all_devices))
                
            self.last_devices = all_devices
            
        except Exception as e:
            print(f"USBMonitor: Scan error: {e}")

    def get_usb_devices(self):
        devices = set()
        
        print("USBMonitor: Scanning for USB devices...")
        
        try:
            result = subprocess.run(
                ['lsblk', '-J', '-o', 'NAME,TYPE,MOUNTPOINT,RM,SIZE,MODEL,VENDOR'],
                capture_output=True, text=True, timeout=10
            )
            if result.returncode == 0:
                import json
                data = json.loads(result.stdout)
                for device in data.get('blockdevices', []):
                    device_name = device.get('name', '')
                    is_removable = device.get('rm') == '1'
                    device_type = device.get('type', '')
                    
                    if (is_removable or 
                        self.looks_like_usb_storage(device) or 
                        device_type == 'disk'):
                        
                        dev_path = f"/dev/{device_name}"
                        devices.add(dev_path)
                        print(f"USBMonitor: Found device: {dev_path} (removable: {is_removable})")
                        
                        for child in device.get('children', []):
                            child_name = child.get('name', '')
                            dev_path = f"/dev/{child_name}"
                            devices.add(dev_path)
                            print(f"USBMonitor: Found partition: {dev_path}")
                            
        except Exception as e:
            print(f"USBMonitor: lsblk method failed: {e}")

        try:
            by_path = '/dev/disk/by-path'
            if os.path.exists(by_path):
                for link in os.listdir(by_path):
                    if any(usb_indicator in link for usb_indicator in ['usb', 'usb-']):
                        link_path = os.path.join(by_path, link)
                        if os.path.islink(link_path):
                            real_path = os.path.realpath(link_path)
                            devices.add(real_path)
                            print(f"USBMonitor: Found by-path USB: {real_path} -> {link}")
        except Exception as e:
            print(f"USBMonitor: by-path method failed: {e}")

        try:
            by_id = '/dev/disk/by-id'
            if os.path.exists(by_id):
                for link in os.listdir(by_id):
                    if any(usb_indicator in link.lower() for usb_indicator in ['usb', 'ata-']):
                        link_path = os.path.join(by_id, link)
                        if os.path.islink(link_path):
                            real_path = os.path.realpath(link_path)
                            devices.add(real_path)
                            print(f"USBMonitor: Found by-id USB: {real_path} -> {link}")
        except Exception as e:
            print(f"USBMonitor: by-id method failed: {e}")

        try:
            result = subprocess.run(
                ['udevadm', 'info', '--export-db'],
                capture_output=True, text=True, timeout=10
            )
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'ID_BUS=usb' in line and 'DEVPATH=' in line:
                        for dev_line in result.stdout.split('\n'):
                            if 'DEVNAME=' in dev_line and '/dev/sd' in dev_line:
                                dev_path = dev_line.split('=')[1].strip()
                                devices.add(dev_path)
                                print(f"USBMonitor: Found udev USB: {dev_path}")
                                break
        except Exception as e:
            print(f"USBMonitor: udev method failed: {e}")

        print(f"USBMonitor: Total USB devices found: {len(devices)}")
        return devices

    def get_mounted_filesystems(self):
        mounts = set()
        
        try:
            with open('/proc/mounts', 'r') as f:
                for line in f:
                    parts = line.split()
                    if len(parts) >= 2:
                        device = parts[0]
                        mount_point = parts[1]
                        
                        if (mount_point.startswith('/') and 
                            not mount_point.startswith(('/sys', '/proc', '/dev', '/run')) and
                            not any(virtual in device for virtual in ['sysfs', 'proc', 'devpts', 'tmpfs', 'cgroup'])):
                            
                            if device.startswith('/dev/'):
                                mounts.add(device)
                            mounts.add(mount_point)
                            
        except Exception as e:
            print(f"USBMonitor: Error reading mounts: {e}")
            
        mount_dirs = ['/media', '/run/media', '/mnt']
        for mount_dir in mount_dirs:
            if os.path.exists(mount_dir):
                try:
                    for item in os.listdir(mount_dir):
                        item_path = os.path.join(mount_dir, item)
                        if os.path.ismount(item_path):
                            mounts.add(item_path)
                except PermissionError:
                    continue
                    
        return mounts

    def looks_like_usb_storage(self, device_info):
        name = device_info.get('name', '')
        model = device_info.get('model', '')
        vendor = device_info.get('vendor', '')
        
        if name.startswith(('sda', 'nvme', 'mmcblk', 'loop', 'ram', 'sr')):
            return False
            
        usb_indicators = ['flash', 'drive', 'usb', 'pen', 'stick', 'sd', 'cf', 'ms']
        model_lower = model.lower()
        if any(indicator in model_lower for indicator in usb_indicators):
            return True
            
        usb_vendors = ['sandisk', 'kingston', 'samsung', 'transcend', 'pny', 'lexar']
        vendor_lower = vendor.lower()
        if any(usb_vendor in vendor_lower for usb_vendor in usb_vendors):
            return True
            
        return False

    def is_actual_usb_device(self, device_path):
        if not device_path.startswith('/dev/'):
            return False
            
        device_name = os.path.basename(device_path)
        
        if device_name.startswith(('nvme', 'mmcblk', 'loop', 'ram', 'sr')):
            return False
        
        try:
            base_device = device_name.rstrip('0123456789')
            removable_path = f"/sys/block/{base_device}/removable"
            if os.path.exists(removable_path):
                with open(removable_path, 'r') as f:
                    if f.read().strip() == '1':
                        return True
        except:
            pass
            
        try:
            if os.path.exists('/dev/disk/by-path'):
                for link in os.listdir('/dev/disk/by-path'):
                    if 'usb' in link and device_name in link:
                        return True
        except:
            pass
            
        return False

    def on_mount_success(self, device, mount_point):
        message = f"Mounted {os.path.basename(device)} at {mount_point}"
        print(f"USBMonitor: {message}")
        self.status_message.emit(message)
        self.mount_success.emit(device, mount_point)
        QTimer.singleShot(1000, self.scan_devices)

    def on_mount_failed(self, device, error):
        message = f"Failed to mount {os.path.basename(device)}: {error}"
        print(f"USBMonitor: {message}")
        self.status_message.emit(message)

    def stop(self):
        self.running = False
        self.auto_mounter.stop()
        if self.auto_mounter.isRunning():
            self.auto_mounter.wait(3000)

# =============================================================================
# DEVICES PANE
# =============================================================================

class DevicesPane(QWidget):
    device_clicked = pyqtSignal(str)
    device_context_menu = pyqtSignal(str, QPoint)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.main_window = parent
        self.init_ui()
        self.usb_monitor = USBMonitor()
        self.usb_monitor.usb_detected.connect(self.refresh_devices)
        self.usb_monitor.device_removed.connect(self.on_device_removed)
        self.usb_monitor.status_message.connect(self.show_status_message)
        self.usb_monitor.mount_success.connect(self.on_device_mounted)
        self.usb_monitor.start()

    def init_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5)

        header_layout = QHBoxLayout()
        devices_label = QLabel("Devices and Drives")
        devices_label.setStyleSheet("font-weight: bold; color: #00ff9f;")
        refresh_btn = QToolButton()
        refresh_btn.setIcon(QIcon.fromTheme('view-refresh'))
        refresh_btn.setToolTip("Refresh devices")
        refresh_btn.clicked.connect(self.refresh_devices)
        
        mount_btn = QToolButton()
        mount_btn.setIcon(QIcon.fromTheme('media-mount'))
        mount_btn.setToolTip("Scan and mount USB devices")
        mount_btn.clicked.connect(self.scan_and_mount_usb)
        
        header_layout.addWidget(devices_label)
        header_layout.addStretch()
        header_layout.addWidget(mount_btn)
        header_layout.addWidget(refresh_btn)
        layout.addLayout(header_layout)

        self.status_label = QLabel("")
        self.status_label.setStyleSheet("color: #0080ff; font-style: italic;")
        layout.addWidget(self.status_label)

        self.devices_list = QListWidget()
        self.devices_list.setIconSize(QSize(24, 24))
        self.devices_list.itemDoubleClicked.connect(self.on_device_double_clicked)
        self.devices_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.devices_list.customContextMenuRequested.connect(self.show_device_context_menu)
        layout.addWidget(self.devices_list)

        self.refresh_devices()

    def on_device_removed(self, device):
        if device.startswith('/dev/'):
            mount_point = self.get_mount_point_for_device(device)
            if mount_point:
                device = mount_point
        
        if self.main_window:
            for i in range(self.main_window.tab_widget.count()):
                tab = self.main_window.tab_widget.widget(i)
                if hasattr(tab, 'current_path') and tab.current_path.startswith(device):
                    self.main_window.tab_widget.removeTab(i)
                    break
        
        self.refresh_devices()
        
    def get_mount_point_for_device(self, device):
        try:
            result = subprocess.run(['findmnt', '-n', '-o', 'TARGET', '-S', device], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                return result.stdout.strip()
        except:
            pass
        return None

    def on_device_mounted(self, device, mount_point):
        print(f"Device mounted: {device} at {mount_point}")
        QTimer.singleShot(1000, self.refresh_devices)

    def scan_and_mount_usb(self):
        self.status_label.setText("Scanning for USB devices...")
        devices = self.usb_monitor.get_usb_devices()
        for device in devices:
            if self.usb_monitor.is_actual_usb_device({'name': os.path.basename(device)}):
                self.status_label.setText(f"Found USB device: {device}")
                self.usb_monitor.auto_mounter.add_device(device)
        self.status_label.setText("USB scan complete")
        QTimer.singleShot(3000, lambda: self.status_label.setText(""))

    def show_status_message(self, message):
        self.status_label.setText(message)
        QTimer.singleShot(5000, lambda: self.status_label.setText(""))

    def refresh_devices(self, devices_list=None):
        self.devices_list.clear()
        
        try:
            mounts_file = '/proc/mounts'
            if os.path.exists(mounts_file):
                with open(mounts_file, 'r') as f:
                    for line in f:
                        parts = line.split()
                        if len(parts) >= 2:
                            device = parts[0]
                            mount_point = parts[1]
                            if (mount_point.startswith('/') and 
                                os.path.isdir(mount_point) and
                                not mount_point.startswith(('/sys', '/proc', '/dev', '/run')) and
                                not any(x in device for x in ('sysfs', 'proc', 'devpts', 'tmpfs', 'cgroup'))):
                                self.add_device(device, mount_point, is_mounted=True)
        
            self.add_removable_media()
            
            if devices_list:
                for device in devices_list:
                    if isinstance(device, str) and os.path.isdir(device):
                        self.add_device(device, device, is_mounted=True)
                    elif isinstance(device, str) and device.startswith('/dev/'):
                        try:
                            result = subprocess.run(['findmnt', '-n', '-o', 'TARGET', '-S', device], 
                                                  capture_output=True, text=True)
                            if result.returncode == 0 and result.stdout.strip():
                                mount_point = result.stdout.strip()
                                device_name = os.path.basename(device)
                                if not device_name.startswith('sda'):
                                    self.add_device(device, mount_point, is_mounted=True)
                            else:
                                if self.is_usb_device(device):
                                    self.add_unmounted_device(device)
                        except:
                            if self.is_usb_device(device):
                                self.add_unmounted_device(device)
            
            self.add_unmounted_usb_devices()
            
        except Exception as e:
            print(f"Error reading devices: {e}")

    def is_usb_device(self, device_path):
        if not device_path.startswith('/dev/'):
            return False
            
        device_name = os.path.basename(device_path)
        
        if device_name.startswith(('sda', 'nvme', 'mmcblk', 'loop', 'ram', 'sr')):
            return False
            
        try:
            base_device = device_name.rstrip('0123456789')
            removable_path = f"/sys/block/{base_device}/removable"
            if os.path.exists(removable_path):
                with open(removable_path, 'r') as f:
                    if f.read().strip() == '1':
                        return True
        except:
            pass
            
        try:
            if os.path.exists('/dev/disk/by-path'):
                for link in os.listdir('/dev/disk/by-path'):
                    if 'usb' in link and device_name in link:
                        return True
        except:
            pass
            
        try:
            if os.path.exists('/dev/disk/by-id'):
                for link in os.listdir('/dev/disk/by-id'):
                    if 'usb' in link.lower() and device_name in link:
                        return True
        except:
            pass
            
        return False

    def add_device(self, device, mount_point, is_mounted=True):
        if is_mounted and not os.path.isdir(mount_point):
            return
            
        item = QListWidgetItem()
        
        if is_mounted:
            device_name = os.path.basename(mount_point)
            if device_name == '':
                device_name = "Root Filesystem"
            elif device.startswith('/dev/'):
                device_name = os.path.basename(device)
            
            item.setText(f"{device_name}\n{mount_point}")
            item.setData(Qt.UserRole, mount_point)
            
            if 'cdrom' in device or 'dvd' in device:
                icon = QIcon.fromTheme('drive-optical')
            elif 'usb' in device or 'sd' in device:
                icon = QIcon.fromTheme('drive-removable-media')
            else:
                icon = QIcon.fromTheme('drive-harddisk')
        else:
            device_name = os.path.basename(device)
            size_info = self.get_device_size(device)
            item.setText(f"{device_name} (Not Mounted)\n{device} {size_info}")
            item.setData(Qt.UserRole, device)
            icon = QIcon.fromTheme('drive-removable-media')
            item.setForeground(QColor(128, 128, 128))
        
        if icon.isNull():
            icon = self.style().standardIcon(self.style().SP_DriveHDIcon)
        item.setIcon(icon)
        
        item.setData(Qt.UserRole + 1, is_mounted)
        item.setData(Qt.UserRole + 2, device)
        
        self.devices_list.addItem(item)

    def add_unmounted_device(self, device):
        for i in range(self.devices_list.count()):
            item = self.devices_list.item(i)
            item_device = item.data(Qt.UserRole + 2)
            if item_device == device:
                return
        
        self.add_device(device, device, is_mounted=False)

    def add_unmounted_usb_devices(self):
        try:
            result = subprocess.run(['lsblk', '-J', '-o', 'NAME,TYPE,MOUNTPOINT,RM'], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                import json
                data = json.loads(result.stdout)
                for device in data.get('blockdevices', []):
                    is_removable = device.get('rm') == '1'
                    device_name = device.get('name', '')
                    mountpoint = device.get('mountpoint')
                    
                    if is_removable and not mountpoint:
                        dev_path = f"/dev/{device_name}"
                        if self.is_usb_device(dev_path):
                            self.add_unmounted_device(dev_path)
                            
                    for child in device.get('children', []):
                        child_name = child.get('name', '')
                        child_mountpoint = child.get('mountpoint')
                        if is_removable and not child_mountpoint:
                            dev_path = f"/dev/{child_name}"
                            if self.is_usb_device(dev_path):
                                self.add_unmounted_device(dev_path)
                                
        except Exception as e:
            print(f"Error scanning for unmounted USB devices: {e}")

    def get_device_size(self, device):
        try:
            result = subprocess.run(['lsblk', '-n', '-o', 'SIZE', device], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                size = result.stdout.strip()
                return f"({size})"
        except:
            pass
        return ""

    def add_removable_media(self):
        media_dirs = ['/media', '/run/media', '/mnt']
        for media_dir in media_dirs:
            if os.path.exists(media_dir):
                try:
                    for user_dir in os.listdir(media_dir):
                        user_path = os.path.join(media_dir, user_dir)
                        if os.path.isdir(user_path):
                            for device_dir in os.listdir(user_path):
                                device_path = os.path.join(user_path, device_dir)
                                if os.path.isdir(device_path) and os.path.ismount(device_path):
                                    item = QListWidgetItem()
                                    item.setText(f"{device_dir}\n{device_path}")
                                    item.setData(Qt.UserRole, device_path)
                                    item.setIcon(QIcon.fromTheme('drive-removable-media'))
                                    item.setData(Qt.UserRole + 1, True)
                                    item.setData(Qt.UserRole + 2, device_path)
                                    self.devices_list.addItem(item)
                except PermissionError:
                    continue

    def on_device_double_clicked(self, item):
        is_mounted = item.data(Qt.UserRole + 1)
        device_path = item.data(Qt.UserRole + 2)
        
        if is_mounted:
            mount_point = item.data(Qt.UserRole)
            if os.path.exists(mount_point) and os.path.isdir(mount_point):
                self.device_clicked.emit(mount_point)
        else:
            self.mount_device(device_path)

    def mount_device(self, device):
        print(f"Attempting to mount {device}")
        self.status_label.setText(f"Mounting {os.path.basename(device)}...")
        
        self.usb_monitor.auto_mounter.add_device(device)
        
        QTimer.singleShot(2000, self.refresh_devices)

    def create_action(self, text, icon_name, shortcut, slot):
        action = QAction(text, self)
        if icon_name:
            icon = QIcon.fromTheme(icon_name)
            if icon.isNull():
                if icon_name == 'document-open':
                    icon = self.style().standardIcon(self.style().SP_DialogOpenButton)
                elif icon_name == 'tab-new':
                    icon = self.style().standardIcon(self.style().SP_FileDialogNewFolder)
                elif icon_name == 'media-eject':
                    icon = self.style().standardIcon(self.style().SP_DriveCDIcon)
                elif icon_name == 'media-mount':
                    icon = self.style().standardIcon(self.style().SP_DialogApplyButton)
            action.setIcon(icon)
        if shortcut:
            action.setShortcut(QKeySequence(shortcut))
        if slot:
            action.triggered.connect(slot)
        return action

    def show_device_context_menu(self, position):
        item = self.devices_list.itemAt(position)
        if not item:
            return
            
        is_mounted = item.data(Qt.UserRole + 1)
        device_path = item.data(Qt.UserRole + 2)
        mount_point = item.data(Qt.UserRole) if is_mounted else None
        
        menu = QMenu(self)
        
        if is_mounted:
            menu.addAction(self.create_action('Open', 'document-open', None, 
                             lambda: self.device_clicked.emit(mount_point)))
            menu.addAction(self.create_action('Open in New Tab', 'tab-new', None,
                             lambda: self.open_in_new_tab(mount_point)))
            menu.addSeparator()
            
            if self.is_removable_device(mount_point):
                menu.addAction(self.create_action('Safely Remove', 'media-eject', None,
                                 lambda: self.unmount_device(mount_point)))
                menu.addAction(self.create_action('Eject', 'media-eject', None,
                                 lambda: self.eject_device(mount_point)))
        else:
            menu.addAction(self.create_action('Mount', 'media-mount', None,
                             lambda: self.mount_device(device_path)))
            menu.addAction(self.create_action('Mount and Open', 'document-open', None,
                             lambda: self.mount_and_open(device_path)))
        
        menu.exec_(self.devices_list.mapToGlobal(position))

    def mount_and_open(self, device):
        def open_after_mount(dev, mount_point):
            if dev == device:
                QTimer.singleShot(500, lambda: self.device_clicked.emit(mount_point))
                self.usb_monitor.mount_success.disconnect(open_after_mount)
        
        self.usb_monitor.mount_success.connect(open_after_mount)
        self.mount_device(device)

    def is_removable_device(self, mount_point):
        try:
            if any(path in mount_point for path in ['/media/', '/run/media/', '/mnt/']):
                return True
            result = subprocess.run(['findmnt', '-n', '-o', 'FSTYPE', mount_point], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                fstype = result.stdout.strip().lower()
                if fstype in ['vfat', 'exfat', 'ntfs', 'iso9660', 'udf']:
                    return True
        except Exception:
            pass
        return False

    def unmount_device(self, mount_point):
        try:
            self.usb_monitor.auto_mounter.try_unmount_device(mount_point)
        except Exception as e:
            QMessageBox.warning(self, "Unmount Error", f"Failed to unmount device: {str(e)}")

    def eject_device(self, mount_point):
        try:
            result = subprocess.run(['findmnt', '-n', '-o', 'SOURCE', mount_point], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                device = result.stdout.strip()
                result = subprocess.run(['udisksctl', 'power-off', '-b', device], 
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    QMessageBox.information(self, "Eject", "Device ejected successfully")
                else:
                    QMessageBox.warning(self, "Eject Error", "Failed to eject device")
            else:
                QMessageBox.warning(self, "Eject Error", "Could not find device for mount point")
        except Exception as e:
            QMessageBox.warning(self, "Eject Error", f"Failed to eject device: {str(e)}")

    def open_in_new_tab(self, mount_point):
        self.device_context_menu.emit(mount_point, self.mapToGlobal(QPoint(0, 0)))

    def closeEvent(self, event):
        if hasattr(self, 'usb_monitor'):
            self.usb_monitor.stop()
            self.usb_monitor.wait(3000)
        super().closeEvent(event)


# =============================================================================
# ENHANCED PROGRESS DIALOG
# =============================================================================

class EnhancedProgressDialog(QDialog):
    def __init__(self, title, parent=None):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.setModal(True)
        self.resize(400, 150)
        self.setWindowFlags(self.windowFlags() & ~Qt.WindowContextHelpButtonHint)
        layout = QVBoxLayout(self)
        
        self.operation_label = QLabel("Preparing operation...")
        layout.addWidget(self.operation_label)
        
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        layout.addWidget(self.progress_bar)
        
        self.details_label = QLabel("")
        self.details_label.setWordWrap(True)
        layout.addWidget(self.details_label)
        
        button_layout = QHBoxLayout()
        self.pause_button = QToolButton()
        self.pause_button.setText("Pause")
        self.pause_button.clicked.connect(self.toggle_pause)
        self.cancel_button = QToolButton()
        self.cancel_button.setText("Cancel")
        self.cancel_button.clicked.connect(self.cancel_operation)
        button_layout.addWidget(self.pause_button)
        button_layout.addStretch()
        button_layout.addWidget(self.cancel_button)
        layout.addLayout(button_layout)
        self.is_paused = False

    def toggle_pause(self):
        self.is_paused = not self.is_paused
        self.pause_button.setText("Resume" if self.is_paused else "Pause")

    def cancel_operation(self):
        self.reject()

    def update_progress(self, value, operation_text="", details=""):
        self.progress_bar.setValue(value)
        if operation_text:
            self.operation_label.setText(operation_text)
        if details:
            self.details_label.setText(details)


# =============================================================================
# FILE CONFLICT RESOLUTION DIALOG
# =============================================================================

class FileConflictDialog(QDialog):
    def __init__(self, source_file, target_file, parent=None):
        super().__init__(parent)
        self.setWindowTitle("File Conflict")
        self.setModal(True)
        self.resize(500, 300)
        
        layout = QVBoxLayout(self)
        
        message = QLabel(f"A file with the same name already exists in the destination folder.")
        layout.addWidget(message)
        
        info_group = QGroupBox("File Information")
        info_layout = QFormLayout(info_group)
        
        source_info = f"{os.path.basename(source_file)} ({self.get_file_size(source_file)})"
        target_info = f"{os.path.basename(target_file)} ({self.get_file_size(target_file)})"
        
        info_layout.addRow("Source file:", QLabel(source_info))
        info_layout.addRow("Destination file:", QLabel(target_info))
        layout.addWidget(info_group)
        
        options_group = QGroupBox("What would you like to do?")
        options_layout = QVBoxLayout(options_group)
        
        self.replace_btn = QCheckBox("Replace the existing file")
        self.rename_btn = QCheckBox("Rename the new file")
        self.skip_btn = QCheckBox("Skip this file")
        self.apply_to_all = QCheckBox("Apply to all conflicts")
        
        options_layout.addWidget(self.replace_btn)
        options_layout.addWidget(self.rename_btn)
        options_layout.addWidget(self.skip_btn)
        options_layout.addWidget(self.apply_to_all)
        
        layout.addWidget(options_group)
        
        button_layout = QHBoxLayout()
        self.ok_btn = QToolButton()
        self.ok_btn.setText("OK")
        self.ok_btn.clicked.connect(self.accept)
        self.cancel_btn = QToolButton()
        self.cancel_btn.setText("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        
        button_layout.addWidget(self.ok_btn)
        button_layout.addStretch()
        button_layout.addWidget(self.cancel_btn)
        layout.addLayout(button_layout)
        
        self.rename_btn.setChecked(True)

    def get_file_size(self, file_path):
        try:
            size = os.path.getsize(file_path)
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size < 1024.0:
                    return f"{size:.1f} {unit}"
                size /= 1024.0
            return f"{size:.1f} GB"
        except:
            return "Unknown size"

    def get_decision(self):
        if self.replace_btn.isChecked():
            return "replace"
        elif self.rename_btn.isChecked():
            return "rename"
        elif self.skip_btn.isChecked():
            return "skip"
        return "rename"

    def apply_to_all_conflicts(self):
        return self.apply_to_all.isChecked()


# =============================================================================
# FILE BROWSER TAB
# =============================================================================

class FileBrowserTab(QWidget):
    file_dropped = pyqtSignal(list, str, str)
    drag_cut_completed = pyqtSignal(list)
    status_update = pyqtSignal(str, str)

    def __init__(self, path, main_window, parent=None):
        super().__init__(parent)
        print(f"FileBrowserTab initial path: {path}")
        
        if not path or not os.path.exists(path):
            path = QDir.homePath()
            print(f"Path invalid, using home: {path}")
        elif os.path.isfile(path):
            path = os.path.dirname(path)
            print(f"Path is file, using parent: {path}")
        
        self.current_path = os.path.abspath(path)
        print(f"FileBrowserTab final path: {self.current_path}")
        
        self.history = [self.current_path]
        self.history_index = 0
        self.main_window = main_window
        self.init_ui()
        
        self.drag_cut_completed.connect(self.handle_drag_cut_completion)

    def init_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        self.tree_view = SortableTreeView()
        
        filter_flags = QDir.AllEntries | QDir.NoDotAndDotDot | QDir.AllDirs
        if self.main_window.show_hidden:
            filter_flags |= QDir.Hidden
            
        self.list_model = SortableFileSystemModel(show_hidden=self.main_window.show_hidden)
        self.list_model.setRootPath("")
        self.list_model.setFilter(filter_flags)
        self.tree_view.setModel(self.list_model)
        
        self.list_model.setHeaderData(0, Qt.Horizontal, "Name")
        self.list_model.setHeaderData(1, Qt.Horizontal, "Size")
        self.list_model.setHeaderData(2, Qt.Horizontal, "Type")
        self.list_model.setHeaderData(3, Qt.Horizontal, "Date Modified")
        
        self.tree_view.setColumnWidth(0, 300)
        self.tree_view.setColumnWidth(1, 100)
        self.tree_view.setColumnWidth(2, 100)
        self.tree_view.setColumnWidth(3, 150)
        
        root_index = self.list_model.index(self.current_path)
        if root_index.isValid():
            self.tree_view.setRootIndex(root_index)
        else:
            self.current_path = QDir.homePath()
            root_index = self.list_model.index(self.current_path)
            self.tree_view.setRootIndex(root_index)
            
        self.tree_view.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.tree_view.setContextMenuPolicy(Qt.CustomContextMenu)
        layout.addWidget(self.tree_view)
        
        self.tree_view.doubleClicked.connect(self.tree_view_double_clicked)
        self.tree_view.customContextMenuRequested.connect(self.show_context_menu)
        self.tree_view.selectionModel().selectionChanged.connect(self.selection_changed)
        self.tree_view.file_dropped.connect(self.file_dropped.emit)

    def tree_view_double_clicked(self, index):
        path = self.list_model.filePath(index)
        if os.path.isdir(path):
            self.navigate_to_path(path)
        else:
            self.open_file(path)

    def navigate_to_path(self, path):
        if not path or not os.path.exists(path) or not os.path.isdir(path):
            self.status_update.emit("Path no longer exists", path)
            return
            
        self.current_path = os.path.abspath(path)
        root_index = self.list_model.index(self.current_path)
        if root_index.isValid():
            self.tree_view.setRootIndex(root_index)
        else:
            self.current_path = QDir.homePath()
            root_index = self.list_model.index(self.current_path)
            self.tree_view.setRootIndex(root_index)
            
        if self.history_index < len(self.history) - 1:
            self.history = self.history[:self.history_index + 1]
        self.history.append(self.current_path)
        self.history_index = len(self.history) - 1
        self.update_status_bar()

    def go_back(self):
        if self.history_index > 0:
            self.history_index -= 1
            self.navigate_to_path(self.history[self.history_index])

    def go_forward(self):
        if self.history_index < len(self.history) - 1:
            self.history_index += 1
            self.navigate_to_path(self.history[self.history_index])

    def go_up(self):
        parent = os.path.dirname(self.current_path)
        if parent and os.path.exists(parent) and os.path.isdir(parent):
            self.navigate_to_path(parent)

    def go_home(self):
        home_path = os.path.expanduser('~')
        self.navigate_to_path(home_path)

    def refresh(self):
        filter_flags = QDir.AllEntries | QDir.NoDotAndDotDot | QDir.AllDirs
        if self.main_window.show_hidden:
            filter_flags |= QDir.Hidden
        self.list_model.setFilter(filter_flags)
        self.list_model.setRootPath("")
        self.list_model.setRootPath(self.current_path)
        
        root_index = self.list_model.index(self.current_path)
        if root_index.isValid():
            self.tree_view.setRootIndex(root_index)
            
        self.update_status_bar()

    def selection_changed(self):
        self.update_status_bar()

    def update_status_bar(self):
        try:
            if os.path.isdir(self.current_path):
                items = os.listdir(self.current_path)
                file_count = sum(1 for item in items if os.path.isfile(os.path.join(self.current_path, item)))
                folder_count = sum(1 for item in items if os.path.isdir(os.path.join(self.current_path, item)))
                selected_count = len(self.tree_view.selectedIndexes()) // 4
                if selected_count > 0:
                    status_text = f"{selected_count} selected - {file_count} files, {folder_count} folders"
                else:
                    status_text = f"{file_count} files, {folder_count} folders"
                self.status_update.emit(status_text, self.current_path)
            else:
                self.status_update.emit("Invalid directory", self.current_path)
        except PermissionError:
            self.status_update.emit("Permission denied", self.current_path)
        except FileNotFoundError:
            self.status_update.emit("Path not found", self.current_path)
        except NotADirectoryError:
            self.status_update.emit("Not a directory", self.current_path)

    def show_context_menu(self, position):
        menu = QMenu(self)
        index = self.tree_view.indexAt(position)
        if index.isValid():
            selected_count = len(self.tree_view.selectedIndexes()) // 4
            path = self.list_model.filePath(index)
            if os.path.isdir(path):
                menu.addAction(self.main_window.create_action('Open', 'document-open', 'Return', self.open_selected))
                menu.addAction(self.main_window.create_action('Open in New Tab', 'tab-new', 'Ctrl+Return', lambda: self.main_window.open_in_new_tab(path)))
                menu.addAction(self.main_window.create_action('Open in New Window', 'window-new', None, lambda: self.main_window.open_in_new_window(path)))
                
                menu.addSeparator()
                menu.addAction(self.main_window.create_action('Open in Terminal', 'utilities-terminal', 'F4', lambda: self.main_window.open_folder_in_terminal(path)))
                menu.addAction(self.main_window.create_action('Open as Root', 'system-software-install', None, lambda: self.main_window.open_folder_as_root(path)))
                
            else:
                menu.addAction(self.main_window.create_action('Open', 'document-open', 'Return', self.open_selected))
                menu.addAction(self.main_window.create_action('Open With...', 'system-run', None, self.open_with))
                if self.main_window.is_file_executable(path):
                    menu.addAction(self.main_window.create_action('Remove Executable Permission', 'application-x-executable', None, self.main_window.toggle_executable))
                else:
                    menu.addAction(self.main_window.create_action('Make Executable', 'application-x-executable', None, self.main_window.toggle_executable))
            
            menu.addSeparator()
            
            hint_action = QAction("üí° Drag with Alt key to cut, drag normally to copy", self)
            hint_action.setEnabled(False)
            menu.addAction(hint_action)
            menu.addSeparator()
            
            menu.addAction(self.main_window.create_action('Cut', 'edit-cut', 'Ctrl+X', self.main_window.cut_selected))
            menu.addAction(self.main_window.create_action('Copy', 'edit-copy', 'Ctrl+C', self.main_window.copy_selected))
            if self.main_window.clipboard_paths:
                menu.addAction(self.main_window.create_action('Paste', 'edit-paste', 'Ctrl+V', self.main_window.paste_files))
            menu.addSeparator()
            menu.addAction(self.main_window.create_action('Rename', 'edit-rename', 'F2', self.main_window.rename_selected))
            if selected_count > 0:
                menu.addAction(self.main_window.create_action('Move to Trash', 'user-trash', 'Delete', self.main_window.delete_selected))
                menu.addAction(self.main_window.create_action('Delete', 'edit-delete', 'Shift+Delete', self.main_window.permanent_delete))
            menu.addSeparator()
            menu.addAction(self.main_window.create_action('Properties', 'document-properties', 'Alt+Return', self.main_window.show_properties))
        else:
            if self.main_window.clipboard_paths:
                menu.addAction(self.main_window.create_action('Paste', 'edit-paste', 'Ctrl+V', self.main_window.paste_files))
                menu.addSeparator()
            menu.addAction(self.main_window.create_action('Create Folder', 'folder-new', 'Ctrl+Shift+N', self.main_window.new_folder))
            menu.addAction(self.main_window.create_action('Create Document', 'document-new', None, self.main_window.new_file))
            menu.addSeparator()
            
            menu.addAction(self.main_window.create_action('Open in Terminal', 'utilities-terminal', 'F4', self.main_window.open_in_terminal))
            menu.addAction(self.main_window.create_action('Open as Root', 'system-software-install', None, self.main_window.open_as_root))
            
            menu.addSeparator()
            menu.addAction(self.main_window.create_action('Properties', 'document-properties', 'Alt+Return', self.main_window.show_properties))
        menu.exec_(self.tree_view.viewport().mapToGlobal(position))

    def open_selected(self):
        indexes = self.tree_view.selectedIndexes()
        if indexes:
            path = self.list_model.filePath(indexes[0])
            if os.path.isdir(path):
                self.navigate_to_path(path)
            else:
                self.open_file(path)

    def open_file(self, path):
        try:
            if path.lower().endswith('.appimage') and os.access(path, os.X_OK):
                subprocess.Popen([path])
            elif sys.platform.startswith('linux'):
                subprocess.run(['xdg-open', path])
            elif sys.platform == 'darwin':
                subprocess.run(['open', path])
            elif sys.platform == 'win32':
                os.startfile(path)
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not open file: {str(e)}")

    def open_with(self):
        indexes = self.tree_view.selectedIndexes()
        if indexes:
            path = self.list_model.filePath(indexes[0])
            if os.path.isfile(path):
                app, ok = QInputDialog.getText(self, "Open With", "Enter application name:")
                if ok and app:
                    try:
                        subprocess.run([app, path])
                    except Exception as e:
                        QMessageBox.warning(self, "Error", f"Could not open file with {app}: {str(e)}")

    def handle_drag_cut_completion(self, file_paths):
        reply = QMessageBox.question(
            self,
            "Cut Operation",
            f"Cut operation completed. Delete {len(file_paths)} source file(s)?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )
        
        if reply == QMessageBox.Yes:
            failed_deletions = []
            for path in file_paths:
                try:
                    if os.path.isdir(path):
                        shutil.rmtree(path)
                    else:
                        os.remove(path)
                except Exception as e:
                    failed_deletions.append(f"{path}: {str(e)}")
            
            if failed_deletions:
                QMessageBox.warning(
                    self,
                    "Some Files Could Not Be Deleted",
                    f"Failed to delete:\n" + "\n".join(failed_deletions[:5]) +
                    ("\n..." if len(failed_deletions) > 5 else "")
                )
            
            self.refresh()


# =============================================================================
# CLIPBOARD MONITOR
# =============================================================================

class ClipboardMonitor:
    def __init__(self, parent):
        self.parent = parent
        self.clipboard = QApplication.clipboard()
        self.clipboard.dataChanged.connect(self.on_clipboard_changed)
    
    def on_clipboard_changed(self):
        mime_data = self.clipboard.mimeData()
        if mime_data.hasUrls():
            pass


# =============================================================================
# MAIN FILE MANAGER WINDOW
# =============================================================================

class EcoFileManager(QMainWindow):
    file_dropped = pyqtSignal(list, str, str)

    def __init__(self, path=None):
        super().__init__()
        self.setObjectName("EcoFileManager")
        self.thread_monitor = ThreadMonitor()
        self._cancel_size_calc = False
        
        print(f"Initial path received: {path}")
        
        if path:
            path = os.path.abspath(path)
            print(f"Normalized path: {path}")
            
            if os.path.isfile(path):
                self.current_path = os.path.dirname(path)
                print(f"Path is a file, using parent directory: {self.current_path}")
            elif os.path.isdir(path):
                self.current_path = path
                print(f"Path is a directory: {self.current_path}")
            else:
                parent_dir = os.path.dirname(path)
                if os.path.exists(parent_dir) and os.path.isdir(parent_dir):
                    self.current_path = parent_dir
                    print(f"Path doesn't exist, using parent: {self.current_path}")
                else:
                    self.current_path = QDir.homePath()
                    print(f"Path invalid, using home: {self.current_path}")
        else:
            self.current_path = QDir.homePath()
            print(f"No path provided, using home: {self.current_path}")
        
        self.current_path = os.path.abspath(self.current_path)
        print(f"Final current_path: {self.current_path}")
        
        self.is_root_mode = os.getuid() == 0
        print(f"Root mode: {self.is_root_mode}")
        
        self.history = [self.current_path]
        self.history_index = 0
        self.clipboard_operation = None
        self.clipboard_paths = []
        self.file_operation_thread = None
        self.progress_dialog = None
        self.icon_size = 32
        self.show_hidden = False
        self.current_theme = "Cyberpunk"
        self.settings_manager = SettingsManager()
        self.status_label_left = None
        self.status_label_right = None
        
        self.clipboard_monitor = ClipboardMonitor(self)
        
        self.init_ui()
        
        if self.is_root_mode:
            self.apply_root_indicators()
        
        self.settings_manager.load_window_state(self)

    def copy_to_system_clipboard(self, paths):
        clipboard = QApplication.clipboard()
        mime_data = QMimeData()
        
        mime_data.setText('\n'.join(paths))
        
        urls = [QUrl.fromLocalFile(path) for path in paths]
        mime_data.setUrls(urls)
        
        gnome_format = "copy\n" + '\n'.join([f"file://{path}" for path in paths])
        mime_data.setData("x-special/gnome-copied-files", gnome_format.encode('utf-8'))
        
        uri_list = '\n'.join([f"file://{path}" for path in paths])
        mime_data.setData("text/uri-list", uri_list.encode('utf-8'))
        
        clipboard.setMimeData(mime_data)

    def cut_to_system_clipboard(self, paths):
        clipboard = QApplication.clipboard()
        mime_data = QMimeData()
        
        mime_data.setText('\n'.join(paths))
        
        urls = [QUrl.fromLocalFile(path) for path in paths]
        mime_data.setUrls(urls)
        
        gnome_format = "cut\n" + '\n'.join([f"file://{path}" for path in paths])
        mime_data.setData("x-special/gnome-copied-files", gnome_format.encode('utf-8'))
        
        uri_list = '\n'.join([f"file://{path}" for path in paths])
        mime_data.setData("text/uri-list", uri_list.encode('utf-8'))
        
        clipboard.setMimeData(mime_data)

    def clear_system_clipboard(self):
        QApplication.clipboard().clear()

    def paste_from_system_clipboard(self):
        clipboard = QApplication.clipboard()
        mime_data = clipboard.mimeData()
        
        if mime_data.hasUrls():
            urls = mime_data.urls()
            file_paths = [url.toLocalFile() for url in urls]
            
            current_tab = self.tab_widget.currentWidget()
            if current_tab and file_paths:
                if mime_data.hasFormat("x-special/gnome-copied-files"):
                    data = mime_data.data("x-special/gnome-copied-files").data().decode('utf-8')
                    if data.startswith("cut\n"):
                        self.move_files(file_paths, current_tab.current_path)
                        self.clear_system_clipboard()
                    elif data.startswith("copy\n"):
                        self.copy_files(file_paths, current_tab.current_path)
                else:
                    self.copy_files(file_paths, current_tab.current_path)
                return True
        return False

    def apply_rounded_corners(self):
        if sys.platform.startswith('linux'):
            try:
                self.setAttribute(Qt.WA_TranslucentBackground)
                self.setStyleSheet("""
                    EcoFileManager {
                        background: transparent;
                    }
                    #centralwidget {
                        background: palette(window);
                        border-radius: 12px;
                    }
                """)
                self.centralWidget().setObjectName("centralwidget")
            except:
                pass

    def init_ui(self):
        self.setWindowTitle('Eco File Manager')
        self.setGeometry(100, 100, 1200, 800)
        self.setWindowIcon(self.create_favicon())
        
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)
        
        self.create_menu_bar()
        self.create_toolbar()
        self.create_main_splitter()
        self.create_status_bar()
        self.connect_signals()
        self.load_xdg_folders()

    def create_favicon(self):
        pixmap = QPixmap(64, 64)
        pixmap.fill(Qt.transparent)
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.setBrush(QColor(0, 255, 159))
        painter.setPen(QColor(0, 200, 120))
        painter.drawRoundedRect(8, 12, 48, 40, 5, 5)
        painter.drawRoundedRect(12, 8, 40, 12, 3, 3)
        painter.end()
        return QIcon(pixmap)

    def create_menu_bar(self):
        menubar = self.menuBar()
        
        file_menu = menubar.addMenu('File')
        file_menu.addAction(self.create_action('New Window', 'window-new', 'Ctrl+N', self.new_window))
        file_menu.addAction(self.create_action('New Tab', 'tab-new', 'Ctrl+T', self.new_tab))
        file_menu.addSeparator()
        file_menu.addAction(self.create_action('Create Folder', 'folder-new', 'Ctrl+Shift+N', self.new_folder))
        file_menu.addAction(self.create_action('Create Document', 'document-new', None, self.new_file))
        file_menu.addSeparator()
        file_menu.addAction(self.create_action('Open', 'document-open', 'Ctrl+O', self.open_selected))
        file_menu.addSeparator()
        file_menu.addAction(self.create_action('Rename', 'edit-rename', 'F2', self.rename_selected))
        file_menu.addAction(self.create_action('Move to Trash', 'user-trash', 'Delete', self.delete_selected))
        file_menu.addAction(self.create_action('Delete', 'edit-delete', 'Shift+Delete', self.permanent_delete))
        file_menu.addSeparator()
        file_menu.addAction(self.create_action('Empty Trash', 'edit-delete-shred', 'Ctrl+Shift+Delete', self.empty_trash))
        file_menu.addAction(self.create_action('Open Trash', 'user-trash', None, self.open_trash_folder))
        file_menu.addAction(self.create_action('Trash Info', 'dialog-information', None, self.show_trash_info))
        file_menu.addSeparator()
        file_menu.addAction(self.create_action('Properties', 'document-properties', 'Alt+Return', self.show_properties))
        file_menu.addSeparator()
        file_menu.addAction(self.create_action('Close Tab', 'window-close', 'Ctrl+W', self.close_current_tab))
        file_menu.addAction(self.create_action('Close Window', 'window-close', 'Ctrl+Shift+W', self.close))
        
        edit_menu = menubar.addMenu('Edit')
        edit_menu.addAction(self.create_action('Cut', 'edit-cut', 'Ctrl+X', self.cut_selected))
        edit_menu.addAction(self.create_action('Copy', 'edit-copy', 'Ctrl+C', self.copy_selected))
        edit_menu.addAction(self.create_action('Paste', 'edit-paste', 'Ctrl+V', self.paste_files))
        edit_menu.addAction(self.create_action('Select All', 'edit-select-all', 'Ctrl+A', self.select_all))
        edit_menu.addAction(self.create_action('Select None', 'edit-clear', 'Ctrl+Shift+A', self.select_none))
        edit_menu.addSeparator()
        edit_menu.addAction(self.create_action('Invert Selection', 'edit-select-invert', 'Ctrl+I', self.invert_selection))
        
        view_menu = menubar.addMenu('View')
        self.view_toolbar_action = self.create_action('Toolbar', None, None, self.toggle_toolbar)
        self.view_toolbar_action.setCheckable(True)
        self.view_toolbar_action.setChecked(True)
        self.view_statusbar_action = self.create_action('Statusbar', None, None, self.toggle_statusbar)
        self.view_statusbar_action.setCheckable(True)
        self.view_statusbar_action.setChecked(True)
        self.view_sidebar_action = self.create_action('Sidebar', None, None, self.toggle_sidebar)
        self.view_sidebar_action.setCheckable(True)
        self.view_sidebar_action.setChecked(True)
        view_menu.addAction(self.view_toolbar_action)
        view_menu.addAction(self.view_statusbar_action)
        view_menu.addAction(self.view_sidebar_action)
        view_menu.addSeparator()
        
        view_mode_menu = view_menu.addMenu('View Mode')
        self.view_icons_action = self.create_action('Icons', 'view-list-icons', None, lambda: self.change_view_mode('icons'))
        self.view_icons_action.setCheckable(True)
        self.view_list_action = self.create_action('List', 'view-list-details', None, lambda: self.change_view_mode('list'))
        self.view_list_action.setCheckable(True)
        self.view_list_action.setChecked(True)
        self.view_compact_action = self.create_action('Compact', 'view-list-text', None, lambda: self.change_view_mode('compact'))
        self.view_compact_action.setCheckable(True)
        view_mode_menu.addAction(self.view_icons_action)
        view_mode_menu.addAction(self.view_list_action)
        view_mode_menu.addAction(self.view_compact_action)
        
        zoom_menu = view_menu.addMenu('Zoom')
        zoom_menu.addAction(self.create_action('Zoom In', 'zoom-in', 'Ctrl++', self.zoom_in))
        zoom_menu.addAction(self.create_action('Zoom Out', 'zoom-out', 'Ctrl+-', self.zoom_out))
        zoom_menu.addAction(self.create_action('Reset Zoom', 'zoom-original', 'Ctrl+0', self.reset_zoom))
        
        theme_menu = view_menu.addMenu('Color Themes')
        self.theme_actions = {}
        for theme_name in COLOR_THEMES.keys():
            theme_action = self.create_action(theme_name, None, None, lambda checked, name=theme_name: self.apply_theme(name))
            theme_action.setCheckable(True)
            theme_action.setChecked(theme_name == self.current_theme)
            theme_menu.addAction(theme_action)
            self.theme_actions[theme_name] = theme_action
        
        view_menu.addSeparator()
        self.view_hidden_action = self.create_action('Show Hidden Files', 'view-hidden', 'Ctrl+H', self.toggle_hidden_files)
        self.view_hidden_action.setCheckable(True)
        self.view_hidden_action.setChecked(self.show_hidden)
        view_menu.addAction(self.view_hidden_action)
        
        go_menu = menubar.addMenu('Go')
        go_menu.addAction(self.create_action('Back', 'go-previous', 'Alt+Left', self.go_back))
        go_menu.addAction(self.create_action('Forward', 'go-next', 'Alt+Right', self.go_forward))
        go_menu.addAction(self.create_action('Up', 'go-up', 'Alt+Up', self.go_up))
        go_menu.addSeparator()
        go_menu.addAction(self.create_action('Home', 'go-home', 'Alt+Home', self.go_home))
        go_menu.addAction(self.create_action('Desktop', 'user-desktop', None, lambda: self.navigate_to_path(self.get_xdg_folder('DESKTOP'))))
        go_menu.addAction(self.create_action('Documents', 'folder-documents', None, lambda: self.navigate_to_path(self.get_xdg_folder('DOCUMENTS'))))
        go_menu.addAction(self.create_action('Downloads', 'folder-downloads', None, lambda: self.navigate_to_path(self.get_xdg_folder('DOWNLOAD'))))
        go_menu.addAction(self.create_action('Music', 'folder-music', None, lambda: self.navigate_to_path(self.get_xdg_folder('MUSIC'))))
        go_menu.addAction(self.create_action('Pictures', 'folder-pictures', None, lambda: self.navigate_to_path(self.get_xdg_folder('PICTURES'))))
        go_menu.addAction(self.create_action('Videos', 'folder-videos', None, lambda: self.navigate_to_path(self.get_xdg_folder('VIDEOS'))))
        go_menu.addSeparator()
        go_menu.addAction(self.create_action('Computer', 'computer', None, lambda: self.navigate_to_path('/')))
        go_menu.addAction(self.create_action('Network', 'network-workgroup', None, lambda: self.navigate_to_path('/net')))
        go_menu.addSeparator()
        go_menu.addAction(self.create_action('Recent', 'document-open-recent', None, self.show_recent))

    @staticmethod
    def detect_launch_intent():
        for arg in sys.argv[1:]:
            if arg.startswith('trash:///'):
                return 'trash:///'
            elif arg.startswith('file://'):
                return EcoFileManager.handle_url_scheme(arg)
            elif os.path.isdir(arg):
                return arg
        
        desktop_session = os.environ.get('DESKTOP_SESSION', '').lower()
        xdg_current_desktop = os.environ.get('XDG_CURRENT_DESKTOP', '').lower()
        
        if 'DISPLAY' in os.environ and os.environ.get('DISPLAY'):
            print(f"Desktop launch detected: {desktop_session} / {xdg_current_desktop}")
            return os.path.expanduser('~')
        
        return os.getcwd()
    
    @staticmethod
    def handle_url_scheme(url):
        if url.startswith('file://'):
            from urllib.parse import unquote
            path = unquote(url[7:])
            return path
        elif url.startswith('trash:///'):
            return 'trash:///'
        return None

    def empty_trash(self):
        reply = QMessageBox.question(
            self,
            "Empty Trash",
            "Are you sure you want to permanently delete all items in the trash?\n\nThis action cannot be undone.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            try:
                trash_dirs = self.get_trash_directories()
                if trash_dirs:
                    success = self.permanently_empty_trash(trash_dirs)
                    if success:
                        QMessageBox.information(self, "Success", "Trash has been emptied.")
                        self.refresh()
                    else:
                        QMessageBox.warning(self, "Error", "Failed to empty trash completely.")
                else:
                    QMessageBox.warning(self, "Error", "Could not find trash directory.")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to empty trash: {str(e)}")

    def open_trash_folder(self):
        trash_dirs = self.get_trash_directories()
        if trash_dirs and os.path.exists(trash_dirs['files']):
            self.new_tab(trash_dirs['files'])
        else:
            QMessageBox.information(self, "Info", "Trash folder is empty or not accessible.")

    def show_trash_info(self):
        trash_dirs = self.get_trash_directories()
        if not trash_dirs:
            QMessageBox.information(self, "Trash Info", "Trash directory not found.")
            return
        
        files_dir = trash_dirs['files']
        
        if not os.path.exists(files_dir) or not os.listdir(files_dir):
            QMessageBox.information(self, "Trash Info", "Trash is empty.")
            return
        
        total_size = 0
        item_count = 0
        
        try:
            for item in os.listdir(files_dir):
                item_path = os.path.join(files_dir, item)
                if os.path.exists(item_path):
                    item_count += 1
                    if os.path.isdir(item_path):
                        size = self.calculate_directory_size(item_path)
                    else:
                        size = os.path.getsize(item_path)
                    total_size += size
        except Exception as e:
            print(f"Error calculating trash size: {e}")
        
        info_text = f"Items in trash: {item_count}\nTotal size: {self.format_size(total_size)}"
        QMessageBox.information(self, "Trash Information", info_text)

    def permanently_empty_trash(self, trash_dirs):
        try:
            files_dir = trash_dirs['files']
            info_dir = trash_dirs['info']
            
            deleted_count = 0
            error_count = 0
            
            if os.path.exists(files_dir):
                for item in os.listdir(files_dir):
                    item_path = os.path.join(files_dir, item)
                    try:
                        if os.path.isdir(item_path):
                            shutil.rmtree(item_path)
                        else:
                            os.remove(item_path)
                        deleted_count += 1
                    except Exception as e:
                        print(f"Error deleting {item_path}: {e}")
                        error_count += 1
            
            if os.path.exists(info_dir):
                for info_file in os.listdir(info_dir):
                    if info_file.endswith('.trashinfo'):
                        info_path = os.path.join(info_dir, info_file)
                        try:
                            os.remove(info_path)
                        except Exception as e:
                            print(f"Error deleting info file {info_path}: {e}")
                            error_count += 1
            
            print(f"Trash emptied: {deleted_count} items deleted, {error_count} errors")
            return error_count == 0
            
        except Exception as e:
            print(f"Error emptying trash: {e}")
            return False

    def get_trash_directories(self):
        xdg_data_home = os.environ.get('XDG_DATA_HOME', os.path.expanduser('~/.local/share'))
        trash_top_dir = os.path.join(xdg_data_home, 'Trash')
        
        files_dir = os.path.join(trash_top_dir, 'files')
        info_dir = os.path.join(trash_top_dir, 'info')
        
        try:
            os.makedirs(files_dir, exist_ok=True)
            os.makedirs(info_dir, exist_ok=True)
            return {'files': files_dir, 'info': info_dir}
        except Exception as e:
            print(f"Error creating trash directories: {e}")
            return None

    def open_folder_in_terminal(self, folder_path):
        if not folder_path or not os.path.exists(folder_path) or not os.path.isdir(folder_path):
            QMessageBox.warning(self, "Error", f"Invalid folder: {folder_path}")
            return
            
        print(f"Opening terminal in specific folder: {folder_path}")
        
        try:
            if sys.platform.startswith('linux'):
                terminal_commands = []
                
                if self.is_root_mode:
                    terminal_commands = [
                        'term5',
                        'gnome-terminal',
                        'konsole',
                        'xfce4-terminal',
                        'lxterminal',
                        'mate-terminal',
                        'tilix',
                        'terminator',
                        'xterm',
                        'uxterm'
                    ]
                else:
                    terminal_commands = [
                        'term5',
                        'gnome-terminal',
                        'konsole',
                        'xfce4-terminal',
                        'lxterminal',
                        'mate-terminal',
                        'tilix',
                        'terminator',
                        'xterm',
                        'uxterm'
                    ]
                
                terminal_found = False
                for term in terminal_commands:
                    if shutil.which(term):
                        try:
                            if term == 'term5':
                                subprocess.Popen(['term5'], cwd=folder_path)
                                print(f"‚úÖ Opened term5 in {folder_path}")
                                
                            elif term == 'gnome-terminal':
                                subprocess.Popen(['gnome-terminal', '--working-directory', folder_path])
                            elif term == 'konsole':
                                subprocess.Popen(['konsole', '--workdir', folder_path])
                            elif term == 'xfce4-terminal':
                                subprocess.Popen(['xfce4-terminal', '--working-directory', folder_path])
                            elif term == 'tilix':
                                subprocess.Popen(['tilix', '--working-directory', folder_path])
                            elif term == 'terminator':
                                subprocess.Popen(['terminator', '--working-directory', folder_path])
                            elif term == 'lxterminal':
                                subprocess.Popen(['lxterminal', '--working-directory', folder_path])
                            elif term == 'mate-terminal':
                                subprocess.Popen(['mate-terminal', '--working-directory', folder_path])
                            else:
                                subprocess.Popen([term, '-e', f'bash -c "cd \\"{folder_path}\\" && exec bash"'])
                            
                            terminal_found = True
                            print(f"‚úÖ Opened terminal: {term} in {folder_path}")
                            break
                            
                        except Exception as term_error:
                            print(f"‚ùå Failed to open {term}: {term_error}")
                            continue
                
                if not terminal_found:
                    try:
                        subprocess.Popen(['x-terminal-emulator', '-e', f'bash -c "cd \\"{folder_path}\\" && exec bash"'])
                        print("‚úÖ Opened system default terminal (x-terminal-emulator)")
                        terminal_found = True
                    except Exception as e:
                        print(f"‚ùå x-terminal-emulator failed: {e}")
                
                if not terminal_found:
                    try:
                        subprocess.Popen(['xterm', '-e', f'bash -c "cd \\"{folder_path}\\" && exec bash"'])
                        print("‚úÖ Opened xterm as final fallback")
                    except:
                        QMessageBox.warning(
                            self, 
                            "Terminal Not Found", 
                            "No terminal emulator found.\n\n"
                            "Please install one of:\n"
                            "- term5 (your preferred)\n"
                            "- gnome-terminal (GNOME)\n" 
                            "- konsole (KDE)\n"
                            "- xfce4-terminal (XFCE)\n"
                            "- xterm (basic)\n\n"
                            "Or set your preferred terminal in system settings."
                        )
                    
            elif sys.platform == 'darwin':
                try:
                    applescript = f'''
                    tell application "Terminal"
                        activate
                        do script "cd '{folder_path}' && clear"
                    end tell
                    '''
                    subprocess.run(['osascript', '-e', applescript])
                    print(f"‚úÖ Opened Terminal on macOS in {folder_path}")
                except Exception as mac_error:
                    print(f"‚ùå AppleScript method failed: {mac_error}")
                    try:
                        subprocess.run(['open', '-a', 'Terminal', folder_path])
                    except Exception as mac_error2:
                        QMessageBox.warning(self, "Error", f"Could not open Terminal on macOS: {str(mac_error2)}")
                        
            elif sys.platform == 'win32':
                try:
                    powershell_cmd = f'Start-Process powershell -ArgumentList "-NoExit", "-Command", "cd {folder_path}"'
                    subprocess.run(['powershell', '-Command', powershell_cmd], shell=True)
                    print(f"‚úÖ Opened PowerShell on Windows in {folder_path}")
                except Exception as win_error:
                    print(f"‚ùå PowerShell method failed: {win_error}")
                    try:
                        win_path = folder_path.replace('/', '\\')
                        subprocess.run(['cmd', '/c', 'start', 'cmd', '/k', f'cd /d "{win_path}"'], shell=True)
                    except Exception as win_error2:
                        QMessageBox.warning(self, "Error", f"Could not open terminal on Windows: {str(win_error2)}")
                
            else:
                QMessageBox.information(self, "Not Supported", 
                                      f"Terminal opening not implemented for {sys.platform}")
                
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not open terminal: {str(e)}")
            print(f"‚ùå Terminal opening failed: {e}")

    def open_folder_as_root(self, folder_path):
        try:
            if sys.platform.startswith('linux'):
                if not os.path.exists(folder_path):
                    QMessageBox.warning(self, "Invalid Path", f"The path '{folder_path}' does not exist.")
                    return
                
                if getattr(sys, 'frozen', False):
                    application_path = sys.executable
                else:
                    application_path = sys.executable
                    script_path = os.path.abspath(__file__)
                
                reply = QMessageBox.question(
                    self,
                    "Open as Root",
                    f"Open '{folder_path}' as root?\n\n"
                    f"This will launch a new file manager window with administrator privileges.\n"
                    f"You will need to enter your password.",
                    QMessageBox.Yes | QMessageBox.No,
                    QMessageBox.No
                )
                
                if reply == QMessageBox.Yes:
                    try:
                        env = os.environ.copy()
                        
                        if getattr(sys, 'frozen', False):
                            cmd = ['pkexec', 'env', 
                                  f"DISPLAY={env.get('DISPLAY', '')}", 
                                  f"XAUTHORITY={env.get('XAUTHORITY', '')}",
                                  f"DBUS_SESSION_BUS_ADDRESS={env.get('DBUS_SESSION_BUS_ADDRESS', '')}",
                                  application_path, folder_path]
                        else:
                            cmd = ['pkexec', 'env', 
                                  f"DISPLAY={env.get('DISPLAY', '')}", 
                                  f"XAUTHORITY={env.get('XAUTHORITY', '')}",
                                  f"DBUS_SESSION_BUS_ADDRESS={env.get('DBUS_SESSION_BUS_ADDRESS', '')}",
                                  application_path, script_path, folder_path]
                        
                        print(f"Attempting to run: {' '.join(cmd)}")
                        
                        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                        
                        time.sleep(2)
                        return_code = process.poll()
                        
                        if return_code is not None and return_code != 0:
                            stdout, stderr = process.communicate()
                            print(f"pkexec failed with return code {return_code}")
                            print(f"stderr: {stderr.decode()}")
                            self.open_folder_as_root_fallback(folder_path)
                        else:
                            print(f"Root file manager launched successfully for folder: {folder_path}")
                            
                    except FileNotFoundError:
                        print("pkexec not found, trying fallback methods")
                        self.open_folder_as_root_fallback(folder_path)
                    except Exception as e:
                        QMessageBox.critical(self, "Error", f"Failed to open as root: {str(e)}")
                        print(f"Error details: {e}")
            else:
                QMessageBox.information(self, "Not Supported", "Open as Root is only supported on Linux.")
                
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not open as root: {str(e)}")

    def open_folder_as_root_fallback(self, folder_path):
        methods = [
            ('gksu', ['gksu']),
            ('kdesu', ['kdesu']),
            ('sudo', ['sudo', '-H']),
        ]
        
        for method_name, base_cmd in methods:
            if shutil.which(base_cmd[0]):
                reply = QMessageBox.question(
                    self,
                    f"Use {method_name} instead?",
                    f"pkexec not found. Use {method_name} instead?\n\n"
                    f"This will launch the file manager with root privileges using {method_name}.",
                    QMessageBox.Yes | QMessageBox.No,
                    QMessageBox.No
                )
                
                if reply == QMessageBox.Yes:
                    try:
                        if getattr(sys, 'frozen', False):
                            application_path = sys.executable
                            cmd = base_cmd + [application_path, folder_path]
                        else:
                            application_path = sys.executable
                            script_path = os.path.abspath(__file__)
                            if base_cmd[0] in ['gksu', 'kdesu']:
                                cmd = base_cmd + [f"{application_path} {script_path} {folder_path}"]
                            else:
                                cmd = base_cmd + [application_path, script_path, folder_path]
                        
                        print(f"Trying {method_name} with command: {' '.join(cmd)}")
                        subprocess.Popen(cmd)
                        
                        QMessageBox.information(
                            self,
                            "Opening as Root",
                            f"File manager is opening as root using {method_name}.\n"
                            f"Enter your password when prompted."
                        )
                        return
                        
                    except Exception as e:
                        print(f"{method_name} failed: {e}")
                        continue
        
        QMessageBox.critical(
            self,
            "Error",
            "No privilege escalation tool found.\n\n"
            "Please install one of:\n"
            "- policykit-1 (for pkexec)\n"
            "- gksu\n"
            "- kdesu\n\n"
            "On Ubuntu/Debian:\n"
            "sudo apt install policykit-1-gnome\n"
            "or\n"
            "sudo apt install gksu"
        )

    def create_action(self, text, icon_name, shortcut, slot=None):
        action = QAction(text, self)
        if icon_name:
            icon = QIcon.fromTheme(icon_name)
            if icon.isNull():
                icon_fallbacks = {
                    'go-previous': self.style().standardIcon(self.style().SP_ArrowBack),
                    'go-next': self.style().standardIcon(self.style().SP_ArrowForward),
                    'go-up': self.style().standardIcon(self.style().SP_ArrowUp),
                    'go-home': self.style().standardIcon(self.style().SP_DirHomeIcon),
                    'view-refresh': self.style().standardIcon(self.style().SP_BrowserReload),
                    'edit-delete': self.style().standardIcon(self.style().SP_TrashIcon),
                    'user-trash': self.style().standardIcon(self.style().SP_TrashIcon),
                    'computer': self.style().standardIcon(self.style().SP_ComputerIcon),
                    'folder-new': self.style().standardIcon(self.style().SP_FileDialogNewFolder),
                    'document-new': self.style().standardIcon(self.style().SP_FileIcon),
                    'edit-cut': self.style().standardIcon(self.style().SP_FileDialogDetailedView),
                    'edit-copy': self.style().standardIcon(self.style().SP_FileDialogContentsView),
                    'edit-paste': self.style().standardIcon(self.style().SP_DialogOkButton),
                    'zoom-in': self.style().standardIcon(self.style().SP_ArrowUp),
                    'zoom-out': self.style().standardIcon(self.style().SP_ArrowDown),
                    'zoom-original': self.style().standardIcon(self.style().SP_BrowserReload),
                    'utilities-terminal': self.style().standardIcon(self.style().SP_ComputerIcon),
                    'application-x-executable': self.style().standardIcon(self.style().SP_DialogApplyButton),
                    'tab-new': self.style().standardIcon(self.style().SP_FileDialogNewFolder),
                    'window-new': self.style().standardIcon(self.style().SP_FileDialogNewFolder),
                    'application-exit': self.style().standardIcon(self.style().SP_DialogCloseButton),
                    'document-open': self.style().standardIcon(self.style().SP_DialogOpenButton),
                    'system-run': self.style().standardIcon(self.style().SP_MediaPlay),
                    'system-software-install': self.style().standardIcon(self.style().SP_ComputerIcon),
                    'document-properties': self.style().standardIcon(self.style().SP_FileDialogDetailedView),
                    'view-hidden': self.style().standardIcon(self.style().SP_FileDialogDetailedView),
                    'media-eject': self.style().standardIcon(self.style().SP_DriveCDIcon),
                    'media-mount': self.style().standardIcon(self.style().SP_DialogApplyButton),
                    'view-list-icons': self.style().standardIcon(self.style().SP_FileDialogDetailedView),
                    'view-list-details': self.style().standardIcon(self.style().SP_FileDialogContentsView),
                    'view-list-text': self.style().standardIcon(self.style().SP_FileDialogListView)
                }
                icon = icon_fallbacks.get(icon_name, self.style().standardIcon(self.style().SP_FileIcon))
            action.setIcon(icon)
        if shortcut:
            action.setShortcut(QKeySequence(shortcut))
        if slot:
            action.triggered.connect(slot)
        return action

    def create_toolbar(self):
        self.toolbar = QToolBar()
        self.toolbar.setObjectName("main_toolbar")
        self.toolbar.setIconSize(QSize(16, 16))
        self.toolbar.setMovable(False)
        self.addToolBar(self.toolbar)
        
        nav_widget = QWidget()
        nav_layout = QHBoxLayout(nav_widget)
        nav_layout.setContentsMargins(0, 0, 0, 0)
        nav_layout.setSpacing(2)
        
        self.back_action = self.create_action('Back', 'go-previous', 'Alt+Left', self.go_back)
        self.forward_action = self.create_action('Forward', 'go-next', 'Alt+Right', self.go_forward)
        self.up_action = self.create_action('Up', 'go-up', 'Alt+Up', self.go_up)
        self.home_action = self.create_action('Home', 'go-home', 'Alt+Home', self.go_home)
        self.refresh_action = self.create_action('Refresh', 'view-refresh', 'F5', self.refresh)
        
        back_btn = QToolButton()
        back_btn.setDefaultAction(self.back_action)
        nav_layout.addWidget(back_btn)
        
        forward_btn = QToolButton()
        forward_btn.setDefaultAction(self.forward_action)
        nav_layout.addWidget(forward_btn)
        
        up_btn = QToolButton()
        up_btn.setDefaultAction(self.up_action)
        nav_layout.addWidget(up_btn)
        
        home_btn = QToolButton()
        home_btn.setDefaultAction(self.home_action)
        nav_layout.addWidget(home_btn)
        
        refresh_btn = QToolButton()
        refresh_btn.setDefaultAction(self.refresh_action)
        nav_layout.addWidget(refresh_btn)
        
        self.toolbar.addWidget(nav_widget)
        self.toolbar.addSeparator()
        
        terminal_action = self.create_action('Open in Terminal', 'utilities-terminal', 'F4', self.open_in_terminal)
        terminal_btn = QToolButton()
        terminal_btn.setDefaultAction(terminal_action)
        self.toolbar.addWidget(terminal_btn)
        
        self.toolbar.addSeparator()
        
        address_container = QWidget()
        address_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        address_layout = QHBoxLayout(address_container)
        address_layout.setContentsMargins(5, 0, 5, 0)
        address_layout.setSpacing(5)
        
        location_label = QLabel("Location:")
        location_label.setStyleSheet("color: #00ff9f; padding: 0 5px;")
        address_layout.addWidget(location_label)
        
        self.location_combo = QComboBox()
        self.location_combo.setEditable(True)
        self.location_combo.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.location_combo.setInsertPolicy(QComboBox.NoInsert)
        self.location_combo.setMinimumWidth(300)
        address_layout.addWidget(self.location_combo)
        
        self.toolbar.addWidget(address_container)
        self.toolbar.addWidget(QWidget())

    def create_main_splitter(self):
        main_splitter = QSplitter(Qt.Horizontal)
        main_layout = self.centralWidget().layout()
        main_layout.addWidget(main_splitter, 1)
        
        self.create_sidebar(main_splitter)
        self.create_content_area(main_splitter)
        
        main_splitter.setSizes([250, 750])

    def create_sidebar(self, parent_splitter):
        sidebar_widget = QWidget()
        sidebar_layout = QVBoxLayout(sidebar_widget)
        sidebar_layout.setContentsMargins(0, 0, 0, 0)
        sidebar_layout.setSpacing(0)
        
        sidebar_splitter = QSplitter(Qt.Vertical)
        
        places_group = QGroupBox("Places")
        places_layout = QVBoxLayout(places_group)
        self.places_list = QListWidget()
        self.places_list.setContextMenuPolicy(Qt.CustomContextMenu)
        places_layout.addWidget(self.places_list)
        sidebar_splitter.addWidget(places_group)
        
        tree_group = QGroupBox("Tree")
        tree_layout = QVBoxLayout(tree_group)
        
        filter_flags = QDir.AllEntries | QDir.NoDotAndDotDot | QDir.AllDirs
        if self.show_hidden:
            filter_flags |= QDir.Hidden
            
        self.tree_view = QTreeView()
        self.tree_model = QFileSystemModel()
        self.tree_model.setRootPath("")
        self.tree_model.setFilter(filter_flags)
        self.tree_view.setModel(self.tree_model)
        self.tree_view.setRootIndex(self.tree_model.index(self.current_path))
        self.tree_view.setColumnWidth(0, 200)
        self.tree_view.setSortingEnabled(True)
        self.tree_view.sortByColumn(0, Qt.AscendingOrder)
        self.tree_view.hideColumn(1)
        self.tree_view.hideColumn(2)
        self.tree_view.hideColumn(3)
        tree_layout.addWidget(self.tree_view)
        sidebar_splitter.addWidget(tree_group)
        
        devices_group = QGroupBox("Devices")
        devices_layout = QVBoxLayout(devices_group)
        self.devices_pane = DevicesPane(self)
        self.devices_pane.device_clicked.connect(self.navigate_to_path)
        self.devices_pane.device_context_menu.connect(self.open_in_new_tab)
        devices_layout.addWidget(self.devices_pane)
        sidebar_splitter.addWidget(devices_group)
        
        sidebar_splitter.setSizes([100, 200, 150])
        sidebar_layout.addWidget(sidebar_splitter)
        parent_splitter.addWidget(sidebar_widget)

    def create_content_area(self, parent_splitter):
        content_widget = QWidget()
        content_layout = QVBoxLayout(content_widget)
        content_layout.setContentsMargins(0, 0, 0, 0)
        
        file_toolbar = QToolBar()
        file_toolbar.setObjectName("file_toolbar")
        file_toolbar.setIconSize(QSize(16, 16))
        file_toolbar.setMovable(False)
        
        terminal_action = self.create_action('Open in Terminal', 'utilities-terminal', 'F4', self.open_in_terminal)
        terminal_btn = QToolButton()
        terminal_btn.setDefaultAction(terminal_action)
        file_toolbar.addWidget(terminal_btn)
        
        spacer = QWidget()
        spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        file_toolbar.addWidget(spacer)
        
        view_mode_group = QButtonGroup(self)
        
        icons_btn = QToolButton()
        icons_btn.setCheckable(True)
        icons_btn.setIcon(QIcon.fromTheme('view-list-icons'))
        icons_btn.setToolTip("Icons View")
        icons_btn.setChecked(False)
        icons_btn.clicked.connect(lambda: self.change_view_mode('icons'))
        view_mode_group.addButton(icons_btn)
        file_toolbar.addWidget(icons_btn)
        
        list_btn = QToolButton()
        list_btn.setCheckable(True)
        list_btn.setIcon(QIcon.fromTheme('view-list-details'))
        list_btn.setToolTip("List View")
        list_btn.setChecked(True)
        list_btn.clicked.connect(lambda: self.change_view_mode('list'))
        view_mode_group.addButton(list_btn)
        file_toolbar.addWidget(list_btn)
        
        compact_btn = QToolButton()
        compact_btn.setCheckable(True)
        compact_btn.setIcon(QIcon.fromTheme('view-list-text'))
        compact_btn.setToolTip("Compact View")
        compact_btn.setChecked(False)
        compact_btn.clicked.connect(lambda: self.change_view_mode('compact'))
        view_mode_group.addButton(compact_btn)
        file_toolbar.addWidget(compact_btn)
        
        content_layout.addWidget(file_toolbar)
        
        self.tab_widget = QTabWidget()
        self.tab_widget.setTabsClosable(True)
        self.tab_widget.tabCloseRequested.connect(self.close_tab)
        self.tab_widget.currentChanged.connect(self.tab_changed)
        
        self.new_tab(self.current_path)
        content_layout.addWidget(self.tab_widget)
        parent_splitter.addWidget(content_widget)

    def create_status_bar(self):
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        
        status_widget = QWidget()
        status_layout = QHBoxLayout(status_widget)
        status_layout.setContentsMargins(0, 0, 0, 0)
        status_layout.setSpacing(10)
        
        self.status_label_left = QLabel()
        self.status_label_right = QLabel()
        
        status_layout.addWidget(self.status_label_left)
        status_layout.addStretch()
        
        self.create_zoom_controls(status_layout)
        
        status_layout.addWidget(self.status_label_right)
        
        self.status_bar.addPermanentWidget(status_widget, 1)
        
        self.status_label_left.setText("Ready")
        self.status_label_right.setText(self.current_path)

    def create_zoom_controls(self, parent_layout):
        zoom_out_btn = QToolButton()
        zoom_out_btn.setDefaultAction(self.create_action('Zoom Out', 'zoom-out', 'Ctrl+-', self.zoom_out))
        zoom_out_btn.setFixedSize(24, 24)
        parent_layout.addWidget(zoom_out_btn)
        
        self.zoom_slider = QSlider(Qt.Horizontal)
        self.zoom_slider.setMinimum(16)
        self.zoom_slider.setMaximum(128)
        self.zoom_slider.setValue(self.icon_size)
        self.zoom_slider.setTickPosition(QSlider.NoTicks)
        self.zoom_slider.setMaximumWidth(100)
        self.zoom_slider.setFixedHeight(20)
        self.zoom_slider.valueChanged.connect(self.on_zoom_changed)
        parent_layout.addWidget(self.zoom_slider)
        
        zoom_in_btn = QToolButton()
        zoom_in_btn.setDefaultAction(self.create_action('Zoom In', 'zoom-in', 'Ctrl++', self.zoom_in))
        zoom_in_btn.setFixedSize(24, 24)
        parent_layout.addWidget(zoom_in_btn)
        
        reset_zoom_btn = QToolButton()
        reset_zoom_btn.setDefaultAction(self.create_action('Reset Zoom', 'zoom-original', 'Ctrl+0', self.reset_zoom))
        reset_zoom_btn.setFixedSize(24, 24)
        parent_layout.addWidget(reset_zoom_btn)

    def connect_signals(self):
        self.tree_view.clicked.connect(self.tree_view_clicked)
        self.places_list.itemDoubleClicked.connect(self.places_item_double_clicked)
        self.location_combo.activated.connect(self.location_combo_activated)
        self.location_combo.lineEdit().returnPressed.connect(self.location_bar_return_pressed)
        self.file_dropped.connect(self.handle_file_drop)
        self.update_location_combo()

    def apply_root_indicators(self):
        current_title = self.windowTitle()
        if "(Root)" not in current_title:
            self.setWindowTitle(current_title + " (Root) - [ADMINISTRATOR PRIVILEGES]")
        
        root_stylesheet = """
            QMainWindow {
                border: 3px solid #ff4444;
                border-radius: 8px;
            }
            QStatusBar {
                background-color: #330000;
                color: #ff4444;
                font-weight: bold;
                border-top: 2px solid #ff4444;
            }
            QToolBar {
                border-bottom: 2px solid #ff4444;
            }
            #main_toolbar {
                border-bottom: 2px solid #ff4444;
            }
        """
        
        current_stylesheet = self.styleSheet()
        self.setStyleSheet(current_stylesheet + root_stylesheet)
        
        if hasattr(self, 'status_label_left') and self.status_label_left is not None:
            self.status_label_left.setText("‚ö†Ô∏è RUNNING AS ROOT - BE CAREFUL!")
            self.status_label_left.setStyleSheet("color: #ff4444; font-weight: bold; background-color: #330000; padding: 4px; border-radius: 3px;")
        
        if hasattr(self, 'status_label_right') and self.status_label_right is not None:
            self.status_label_right.setText("ROOT PRIVILEGES")
            self.status_label_right.setStyleSheet("color: #ff8888; font-weight: bold; background-color: #220000; padding: 4px; border-radius: 3px;")
        
        self.setWindowIcon(self.create_root_favicon())
        self.add_root_warning_to_menu()

    def create_root_favicon(self):
        pixmap = QPixmap(64, 64)
        pixmap.fill(Qt.transparent)
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        
        painter.setBrush(QColor(255, 68, 68))
        painter.setPen(QColor(200, 40, 40))
        painter.drawRoundedRect(8, 12, 48, 40, 5, 5)
        
        painter.drawRoundedRect(12, 8, 40, 12, 3, 3)
        
        painter.setPen(QColor(255, 255, 255))
        painter.setFont(QFont("Arial", 24, QFont.Bold))
        painter.drawText(28, 45, "!")
        
        painter.end()
        return QIcon(pixmap)

    def add_root_warning_to_menu(self):
        menubar = self.menuBar()
        
        warning_action = QAction("‚ö†Ô∏è RUNNING AS ROOT", self)
        warning_action.setEnabled(False)
        warning_action.setIcon(self.create_root_favicon())
        
        menubar.insertAction(menubar.actions()[0] if menubar.actions() else None, warning_action)

    def new_window(self, path=None):
        if path is None:
            path = self.current_path
        new_win = EcoFileManager(path)
        new_win.show()
        return new_win

    def new_tab(self, path=None):
        if path is None:
            path = self.current_path
        
        print(f"new_tab received path: {path}")
        
        if not path:
            path = QDir.homePath()
        elif os.path.isfile(path):
            path = os.path.dirname(path)
        elif not os.path.exists(path) or not os.path.isdir(path):
            parent = os.path.dirname(path)
            while parent and parent != '/' and not os.path.isdir(parent):
                parent = os.path.dirname(parent)
            if os.path.isdir(parent):
                path = parent
            else:
                path = QDir.homePath()
        
        path = os.path.abspath(path)
        print(f"new_tab using path: {path}")
        
        try:
            tab = FileBrowserTab(path, self)
            tab.file_dropped.connect(self.handle_file_drop)
            tab.status_update.connect(self.update_status_bar_from_tab)
            
            tab_name = os.path.basename(path) or path
            index = self.tab_widget.addTab(tab, tab_name)
            self.tab_widget.setCurrentIndex(index)
            
            self.current_path = path
            self.setWindowTitle(f"Eco File Manager - {path}")
        except Exception as e:
            print(f"Error creating tab: {e}")
            fallback_path = QDir.homePath()
            print(f"Falling back to: {fallback_path}")
            self.new_tab(fallback_path)

    def close_tab(self, index):
        if self.tab_widget.count() <= 1:
            return
        self.tab_widget.removeTab(index)

    def close_current_tab(self):
        current_index = self.tab_widget.currentIndex()
        self.close_tab(current_index)

    def tab_changed(self, index):
        if index >= 0:
            current_tab = self.tab_widget.currentWidget()
            if current_tab:
                if not os.path.exists(current_tab.current_path):
                    self.close_tab(index)
                    return
                    
                self.current_path = current_tab.current_path
                self.location_combo.setEditText(self.current_path)
                
                tree_index = self.tree_model.index(self.current_path)
                if tree_index.isValid():
                    self.tree_view.setCurrentIndex(tree_index)
                    self.tree_view.setExpanded(tree_index, True)
                    
                self.setWindowTitle(f"Eco File Manager - {self.current_path}")
                
                try:
                    current_tab.update_status_bar()
                except Exception as e:
                    print(f"Error updating status bar: {e}")

    def update_status_bar_from_tab(self, left_text, right_text):
        try:
            if hasattr(self, 'status_label_left') and self.status_label_left is not None:
                self.status_label_left.setText(left_text)
            if hasattr(self, 'status_label_right') and self.status_label_right is not None:
                self.status_label_right.setText(right_text)
        except AttributeError as e:
            print(f"Status bar update error: {e}")
            self.statusBar().showMessage(f"{left_text} - {right_text}")

    def is_file_executable(self, file_path):
        try:
            file_stat = os.stat(file_path)
            return (file_stat.st_mode & stat.S_IXUSR) or (file_stat.st_mode & stat.S_IXGRP) or (file_stat.st_mode & stat.S_IXOTH)
        except OSError:
            return False

    def toggle_executable(self):
        current_tab = self.tab_widget.currentWidget()
        if not current_tab:
            return
        indexes = current_tab.tree_view.selectedIndexes()
        if not indexes:
            return
        files_to_process = []
        for index in indexes:
            if index.column() == 0:
                path = current_tab.list_model.filePath(index)
                if os.path.isfile(path):
                    files_to_process.append(path)
        if not files_to_process:
            QMessageBox.information(self, "Info", "No files selected. Only files can be made executable.")
            return
            
        executable_files = [f for f in files_to_process if self.is_file_executable(f)]
        if executable_files:
            reply = QMessageBox.question(
                self, 
                "Remove Executable Permission",
                f"{len(executable_files)} of {len(files_to_process)} selected file(s) are executable.\n"
                f"Do you want to remove executable permission from all selected files?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            if reply == QMessageBox.Yes:
                self.remove_executable_permission(files_to_process)
        else:
            reply = QMessageBox.question(
                self,
                "Make Files Executable",
                f"Make {len(files_to_process)} selected file(s) executable?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )
            if reply == QMessageBox.Yes:
                self.add_executable_permission(files_to_process)

    def add_executable_permission(self, file_paths):
        try:
            progress = QProgressDialog("Making files executable...", "Cancel", 0, len(file_paths), self)
            progress.setWindowTitle("Processing")
            progress.setWindowModality(Qt.WindowModal)
            progress.setMinimumDuration(0)
            progress.show()
            
            failed_files = []
            successful_count = 0
            
            for i, file_path in enumerate(file_paths):
                if progress.wasCanceled():
                    break
                    
                progress.setValue(i)
                progress.setLabelText(f"Processing: {os.path.basename(file_path)}")
                QApplication.processEvents()
                
                try:
                    current_mode = os.stat(file_path).st_mode
                    new_mode = current_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH
                    os.chmod(file_path, new_mode)
                    
                    if self.is_file_executable(file_path):
                        successful_count += 1
                    else:
                        failed_files.append(f"{file_path} (permission change failed)")
                except (OSError, PermissionError) as e:
                    failed_files.append(f"{file_path} ({str(e)})")
            
            progress.close()
            
            if failed_files:
                QMessageBox.warning(
                    self,
                    "Some Files Failed",
                    f"Successfully made {successful_count} file(s) executable.\n"
                    f"Failed to make these files executable:\n" + "\n".join(failed_files[:10]) + 
                    ("\n... and more" if len(failed_files) > 10 else "")
                )
            else:
                QMessageBox.information(
                    self,
                    "Complete",
                    f"Successfully made {successful_count} file(s) executable."
                )
            self.refresh()
        except Exception as e:
            progress.close()
            QMessageBox.critical(self, "Error", f"Failed to make files executable: {str(e)}")

    def remove_executable_permission(self, file_paths):
        try:
            progress = QProgressDialog("Removing executable permission...", "Cancel", 0, len(file_paths), self)
            progress.setWindowTitle("Processing")
            progress.setWindowModality(Qt.WindowModal)
            progress.setMinimumDuration(0)
            progress.show()
            
            failed_files = []
            successful_count = 0
            
            for i, file_path in enumerate(file_paths):
                if progress.wasCanceled():
                    break
                    
                progress.setValue(i)
                progress.setLabelText(f"Processing: {os.path.basename(file_path)}")
                QApplication.processEvents()
                
                try:
                    current_mode = os.stat(file_path).st_mode
                    new_mode = current_mode & ~stat.S_IXUSR & ~stat.S_IXGRP & ~stat.S_IXOTH
                    os.chmod(file_path, new_mode)
                    
                    if not self.is_file_executable(file_path):
                        successful_count += 1
                    else:
                        failed_files.append(f"{file_path} (permission change failed)")
                except (OSError, PermissionError) as e:
                    failed_files.append(f"{file_path} ({str(e)})")
            
            progress.close()
            
            if failed_files:
                QMessageBox.warning(
                    self,
                    "Some Files Failed",
                    f"Successfully removed executable permission from {successful_count} file(s).\n"
                    f"Failed to remove executable permission from:\n" + "\n".join(failed_files[:10]) + 
                    ("\n... and more" if len(failed_files) > 10 else "")
                )
            else:
                QMessageBox.information(
                    self,
                    "Complete",
                    f"Successfully removed executable permission from {successful_count} file(s)."
                )
            self.refresh()
        except Exception as e:
            progress.close()
            QMessageBox.critical(self, "Error", f"Failed to remove executable permission: {str(e)}")

    def open_in_terminal(self):
        current_tab = self.tab_widget.currentWidget()
        if current_tab:
            path = current_tab.current_path
        else:
            path = self.current_path
        
        if not os.path.exists(path) or not os.path.isdir(path):
            QMessageBox.warning(self, "Error", f"Cannot open terminal: Path '{path}' does not exist or is not a directory")
            return
            
        print(f"Opening terminal in: {path}")
        
        try:
            if sys.platform.startswith('linux'):
                terminal_commands = []
                
                if self.is_root_mode:
                    terminal_commands = [
                        'term5',
                        'gnome-terminal',
                        'konsole',
                        'xfce4-terminal',
                        'lxterminal',
                        'mate-terminal',
                        'tilix',
                        'terminator',
                        'xterm',
                        'uxterm'
                    ]
                else:
                    terminal_commands = [
                        'term5',
                        'gnome-terminal',
                        'konsole',
                        'xfce4-terminal',
                        'lxterminal',
                        'mate-terminal',
                        'tilix',
                        'terminator',
                        'xterm',
                        'uxterm'
                    ]
                
                terminal_found = False
                for term in terminal_commands:
                    if shutil.which(term):
                        try:
                            if term == 'term5':
                                subprocess.Popen(['term5'], cwd=path)
                                print(f"‚úÖ Opened term5 in {path}")
                                
                            elif term == 'gnome-terminal':
                                subprocess.Popen(['gnome-terminal', '--working-directory', path])
                            elif term == 'konsole':
                                subprocess.Popen(['konsole', '--workdir', path])
                            elif term == 'xfce4-terminal':
                                subprocess.Popen(['xfce4-terminal', '--working-directory', path])
                            elif term == 'tilix':
                                subprocess.Popen(['tilix', '--working-directory', path])
                            elif term == 'terminator':
                                subprocess.Popen(['terminator', '--working-directory', path])
                            elif term == 'lxterminal':
                                subprocess.Popen(['lxterminal', '--working-directory', path])
                            elif term == 'mate-terminal':
                                subprocess.Popen(['mate-terminal', '--working-directory', path])
                            else:
                                subprocess.Popen([term, '-e', f'bash -c "cd \\"{path}\\" && exec bash"'])
                            
                            terminal_found = True
                            print(f"‚úÖ Opened terminal: {term} in {path}")
                            break
                            
                        except Exception as term_error:
                            print(f"‚ùå Failed to open {term}: {term_error}")
                            continue
                
                if not terminal_found:
                    try:
                        subprocess.Popen(['x-terminal-emulator', '-e', f'bash -c "cd \\"{path}\\" && exec bash"'])
                        print("‚úÖ Opened system default terminal (x-terminal-emulator)")
                        terminal_found = True
                    except Exception as e:
                        print(f"‚ùå x-terminal-emulator failed: {e}")
                
                if not terminal_found:
                    try:
                        subprocess.Popen(['xterm', '-e', f'bash -c "cd \\"{path}\\" && exec bash"'])
                        print("‚úÖ Opened xterm as final fallback")
                    except:
                        QMessageBox.warning(
                            self, 
                            "Terminal Not Found", 
                            "No terminal emulator found.\n\n"
                            "Please install one of:\n"
                            "- term5 (your preferred)\n"
                            "- gnome-terminal (GNOME)\n" 
                            "- konsole (KDE)\n"
                            "- xfce4-terminal (XFCE)\n"
                            "- xterm (basic)\n\n"
                            "Or set your preferred terminal in system settings."
                        )
                    
            elif sys.platform == 'darwin':
                try:
                    applescript = f'''
                    tell application "Terminal"
                        activate
                        do script "cd '{path}' && clear"
                    end tell
                    '''
                    subprocess.run(['osascript', '-e', applescript])
                    print(f"‚úÖ Opened Terminal on macOS in {path}")
                except Exception as mac_error:
                    print(f"‚ùå AppleScript method failed: {mac_error}")
                    try:
                        subprocess.run(['open', '-a', 'Terminal', path])
                    except Exception as mac_error2:
                        QMessageBox.warning(self, "Error", f"Could not open Terminal on macOS: {str(mac_error2)}")
                        
            elif sys.platform == 'win32':
                try:
                    powershell_cmd = f'Start-Process powershell -ArgumentList "-NoExit", "-Command", "cd {path}"'
                    subprocess.run(['powershell', '-Command', powershell_cmd], shell=True)
                    print(f"‚úÖ Opened PowerShell on Windows in {path}")
                except Exception as win_error:
                    print(f"‚ùå PowerShell method failed: {win_error}")
                    try:
                        win_path = path.replace('/', '\\')
                        subprocess.run(['cmd', '/c', 'start', 'cmd', '/k', f'cd /d "{win_path}"'], shell=True)
                    except Exception as win_error2:
                        QMessageBox.warning(self, "Error", f"Could not open terminal on Windows: {str(win_error2)}")
                
            else:
                QMessageBox.information(self, "Not Supported", 
                                      f"Terminal opening not implemented for {sys.platform}")
                
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not open terminal: {str(e)}")
            print(f"‚ùå Terminal opening failed: {e}")

    def open_as_root(self):
        try:
            if sys.platform.startswith('linux'):
                current_tab = self.tab_widget.currentWidget()
                if current_tab:
                    path = current_tab.current_path
                else:
                    path = self.current_path
                
                if not os.path.exists(path):
                    QMessageBox.warning(self, "Invalid Path", f"The path '{path}' does not exist.")
                    return
                
                if getattr(sys, 'frozen', False):
                    application_path = sys.executable
                else:
                    application_path = sys.executable
                    script_path = os.path.abspath(__file__)
                
                reply = QMessageBox.question(
                    self,
                    "Open as Root",
                    f"Open '{path}' as root?\n\n"
                    f"This will launch a new file manager window with administrator privileges.\n"
                    f"You will need to enter your password.",
                    QMessageBox.Yes | QMessageBox.No,
                    QMessageBox.No
                )
                
                if reply == QMessageBox.Yes:
                    try:
                        if getattr(sys, 'frozen', False):
                            cmd = ['pkexec', application_path, path]
                        else:
                            cmd = ['pkexec', application_path, script_path, path]
                        
                        print(f"Attempting to run: {' '.join(cmd)}")
                        
                        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                        
                        time.sleep(1)
                        return_code = process.poll()
                        
                        if return_code is not None and return_code != 0:
                            stdout, stderr = process.communicate()
                            print(f"pkexec failed with return code {return_code}")
                            print(f"stderr: {stderr.decode()}")
                            self.open_as_root_fallback(path)
                        else:
                            QMessageBox.information(
                                self,
                                "Opening as Root",
                                f"File manager is opening '{path}' as root.\n\n"
                                f"Enter your password when prompted."
                            )
                            
                    except FileNotFoundError:
                        print("pkexec not found, trying fallback methods")
                        self.open_as_root_fallback(path)
                    except Exception as e:
                        QMessageBox.critical(self, "Error", f"Failed to open as root: {str(e)}")
                        print(f"Error details: {e}")
                        
            else:
                QMessageBox.information(self, "Not Supported", "Open as Root is only supported on Linux.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not open as root: {str(e)}")

    def open_as_root_fallback(self, path):
        methods = [
            ('gksu', ['gksu']),
            ('kdesu', ['kdesu']),
            ('sudo', ['sudo', '-H']),
        ]
        
        for method_name, base_cmd in methods:
            if shutil.which(base_cmd[0]):
                reply = QMessageBox.question(
                    self,
                    f"Use {method_name} instead?",
                    f"pkexec not found. Use {method_name} instead?\n\n"
                    f"This will launch the file manager with root privileges using {method_name}.",
                    QMessageBox.Yes | QMessageBox.No,
                    QMessageBox.No
                )
                
                if reply == QMessageBox.Yes:
                    try:
                        if getattr(sys, 'frozen', False):
                            application_path = sys.executable
                            cmd = base_cmd + [application_path, path]
                        else:
                            application_path = sys.executable
                            script_path = os.path.abspath(__file__)
                            if base_cmd[0] in ['gksu', 'kdesu']:
                                cmd = base_cmd + [f"{application_path} {script_path} {path}"]
                            else:
                                cmd = base_cmd + [application_path, script_path, path]
                        
                        print(f"Trying {method_name} with command: {' '.join(cmd)}")
                        subprocess.Popen(cmd)
                        
                        QMessageBox.information(
                            self,
                            "Opening as Root",
                            f"File manager is opening as root using {method_name}.\n"
                            f"Enter your password when prompted."
                        )
                        return
                        
                    except Exception as e:
                        print(f"{method_name} failed: {e}")
                        continue
        
        QMessageBox.critical(
            self,
            "Error",
            "No privilege escalation tool found.\n\n"
            "Please install one of:\n"
            "- policykit-1 (for pkexec)\n"
            "- gksu\n"
            "- kdesu\n\n"
            "On Ubuntu/Debian:\n"
            "sudo apt install policykit-1-gnome\n"
            "or\n"
            "sudo apt install gksu"
        )

    def toggle_hidden_files(self):
        self.show_hidden = not self.show_hidden
        
        filter_flags = QDir.AllEntries | QDir.NoDotAndDotDot | QDir.AllDirs
        if self.show_hidden:
            filter_flags |= QDir.Hidden
            
        self.tree_model.setFilter(filter_flags)
        
        for i in range(self.tab_widget.count()):
            tab = self.tab_widget.widget(i)
            if tab:
                tab.list_model.setFilter(filter_flags)
                
        self.view_hidden_action.setChecked(self.show_hidden)
        self.settings_manager.settings.setValue("showHidden", self.show_hidden)
        self.refresh()

    def update_icon_size(self, size):
        self.icon_size = size
        
        current_tab = self.tab_widget.currentWidget()
        if current_tab:
            current_tab.tree_view.setIconSize(QSize(size, size))
            
        self.places_list.setIconSize(QSize(size // 2, size // 2))
        self.devices_pane.devices_list.setIconSize(QSize(size // 2, size // 2))
        self.tree_view.setIconSize(QSize(size // 2, size // 2))
        
        if hasattr(self, 'zoom_slider'):
            self.zoom_slider.blockSignals(True)
            self.zoom_slider.setValue(size)
            self.zoom_slider.blockSignals(False)
            
        self.settings_manager.settings.setValue("iconSize", size)

    def get_current_view_mode(self):
        if self.view_icons_action.isChecked():
            return 'icons'
        elif self.view_list_action.isChecked():
            return 'list'
        elif self.view_compact_action.isChecked():
            return 'compact'
        return 'list'

    def on_zoom_changed(self, value):
        self.update_icon_size(value)

    def zoom_in(self):
        new_size = min(self.icon_size + 16, 128)
        self.update_icon_size(new_size)

    def zoom_out(self):
        new_size = max(self.icon_size - 16, 16)
        self.update_icon_size(new_size)

    def reset_zoom(self):
        self.update_icon_size(32)

    def apply_theme(self, theme_name):
        if theme_name not in COLOR_THEMES:
            return
        self.current_theme = theme_name
        theme = COLOR_THEMES[theme_name]
        
        for action_name, action in self.theme_actions.items():
            action.setChecked(action_name == theme_name)
            
        palette = QPalette()
        palette.setColor(QPalette.Window, QColor(theme['bg']))
        palette.setColor(QPalette.WindowText, QColor(theme['fg']))
        palette.setColor(QPalette.Base, QColor(theme['surface']))
        palette.setColor(QPalette.AlternateBase, QColor(theme['secondary']))
        palette.setColor(QPalette.ToolTipBase, QColor(theme['bg']))
        palette.setColor(QPalette.ToolTipText, QColor(theme['fg']))
        palette.setColor(QPalette.Text, QColor(theme['text_primary']))
        palette.setColor(QPalette.Button, QColor(theme['surface']))
        palette.setColor(QPalette.ButtonText, QColor(theme['text_primary']))
        palette.setColor(QPalette.BrightText, QColor(theme['warning']))
        palette.setColor(QPalette.Link, QColor(theme['accent']))
        palette.setColor(QPalette.Highlight, QColor(theme['highlight']))
        palette.setColor(QPalette.HighlightedText, QColor(theme['bg']))
        palette.setColor(QPalette.Disabled, QPalette.Text, QColor(theme['text_secondary']))
        palette.setColor(QPalette.Disabled, QPalette.ButtonText, QColor(theme['text_secondary']))
        
        self.setPalette(palette)
        QApplication.setPalette(palette)
        self.setStyleSheet(self.generate_stylesheet(theme))
        self.settings_manager.settings.setValue("theme", theme_name)

    def apply_rounded_corners(self):
        if sys.platform.startswith('linux'):
            try:
                self.setAttribute(Qt.WA_TranslucentBackground)
                self.setStyleSheet("""
                    EcoFileManager {
                        background: transparent;
                    }
                    #centralwidget {
                        background: palette(window);
                        border-radius: 12px;
                    }
                """)
            except:
                pass

    def generate_stylesheet(self, theme):
        return f"""
            QMainWindow {{
                background-color: {theme['bg']};
                color: {theme['fg']};
            }}
            QWidget {{
                background-color: {theme['bg']};
                color: {theme['fg']};
            }}
            QMenuBar {{
                background-color: {theme['bg']};
                color: {theme['fg']};
                border: none;
                border-bottom: 1px solid {theme['border']};
                border-top-left-radius: 8px;
                border-top-right-radius: 8px;
            }}
            QMenuBar::item {{
                background-color: transparent;
                padding: 4px 10px;
                border-radius: 4px;
            }}
            QMenuBar::item:selected {{
                background-color: {theme['accent']};
                color: {theme['bg']};
            }}
            QToolBar {{
                background-color: {theme['bg']};
                border: none;
                border-bottom: 1px solid {theme['border']};
                spacing: 3px;
                padding: 3px;
                border-radius: 6px;
            }}
            QToolButton {{
                background-color: transparent;
                color: {theme['text_primary']};
                border: 1px solid transparent;
                padding: 4px;
                border-radius: 6px;
            }}
            QToolButton:hover {{
                background-color: {theme['surface']};
                border: 1px solid {theme['accent']};
                color: {theme['text_primary']};
            }}
            QToolButton:pressed {{
                background-color: {theme['accent']};
                color: {theme['bg']};
            }}
            QTreeView, QListView, QListWidget {{
                background-color: {theme['bg']};
                color: {theme['text_primary']};
                border: 1px solid {theme['border']};
                outline: 0;
                alternate-background-color: {theme['surface']};
                border-radius: 6px;
            }}
            QTreeView::item, QListView::item, QListWidget::item {{
                padding: 4px 8px;
                border: 1px solid transparent;
                border-radius: 4px;
                margin: 1px;
                background-color: transparent;
                color: {theme['text_primary']};
            }}
            QTreeView::item:selected, QListView::item:selected, QListWidget::item:selected {{
                background-color: {theme['accent']};
                color: {theme['bg']};
                border-radius: 4px;
                border: 1px solid {theme['accent_hover']};
            }}
            QTreeView::item:hover, QListView::item:hover, QListWidget::item:hover {{
                background-color: {theme['surface']};
                border: 1px solid {theme['accent_hover']};
                border-radius: 4px;
                color: {theme['text_primary']};
            }}
            QTreeView::item:selected:hover, QListView::item:selected:hover, QListWidget::item:selected:hover {{
                background-color: {theme['accent_hover']};
                color: {theme['bg']};
                border: 1px solid {theme['accent']};
            }}
            QHeaderView::section {{
                background-color: {theme['surface']};
                color: {theme['text_primary']};
                padding: 6px;
                border: 1px solid {theme['border']};
                border-radius: 4px;
                margin: 1px;
            }}
            QStatusBar {{
                background-color: {theme['bg']};
                color: {theme['text_primary']};
                border-top: 1px solid {theme['border']};
                border-bottom-left-radius: 8px;
                border-bottom-right-radius: 8px;
            }}
            QComboBox {{
                background-color: {theme['surface']};
                color: {theme['text_primary']};
                border: 1px solid {theme['border']};
                padding: 3px 10px;
                border-radius: 6px;
            }}
            QComboBox::drop-down {{
                border: none;
                width: 20px;
            }}
            QComboBox::down-arrow {{
                image: none;
                border-left: 4px solid transparent;
                border-right: 4px solid transparent;
                border-top: 4px solid {theme['text_primary']};
                margin-right: 4px;
            }}
            QComboBox QAbstractItemView {{
                background-color: {theme['surface']};
                color: {theme['text_primary']};
                border: 1px solid {theme['border']};
                selection-background-color: {theme['accent']};
                selection-color: {theme['bg']};
                border-radius: 6px;
            }}
            QSlider::groove:horizontal {{
                border: 1px solid {theme['border']};
                height: 6px;
                background: {theme['surface']};
                border-radius: 4px;
            }}
            QSlider::handle:horizontal {{
                background: {theme['accent']};
                border: 1px solid {theme['accent_hover']};
                width: 14px;
                margin: -4px 0;
                border-radius: 7px;
            }}
            QSlider::handle:horizontal:hover {{
                background: {theme['accent_hover']};
            }}
            QMenu {{
                background-color: {theme['surface']};
                color: {theme['text_primary']};
                border: 1px solid {theme['border']};
                border-radius: 6px;
            }}
            QMenu::item {{
                padding: 6px 20px;
                border-radius: 4px;
                color: {theme['text_primary']};
            }}
            QMenu::item:selected {{
                background-color: {theme['accent']};
                color: {theme['bg']};
                border-radius: 4px;
            }}
            QGroupBox {{
                font-weight: bold;
                color: {theme['text_primary']};
                border: 1px solid {theme['border']};
                border-radius: 6px;
                margin-top: 1ex;
                background-color: {theme['bg']};
            }}
            QGroupBox::title {{
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                color: {theme['text_primary']};
                background-color: {theme['bg']};
            }}
            QProgressBar {{
                border: 1px solid {theme['border']};
                border-radius: 4px;
                text-align: center;
                color: {theme['text_primary']};
                background-color: {theme['surface']};
            }}
            QProgressBar::chunk {{
                background-color: {theme['accent']};
                border-radius: 3px;
            }}
            QScrollBar:vertical {{
                background-color: {theme['surface']};
                width: 12px;
                margin: 2px;
                border-radius: 6px;
            }}
            QScrollBar::handle:vertical {{
                background-color: {theme['accent']};
                min-height: 20px;
                border-radius: 6px;
                margin: 2px;
            }}
            QScrollBar::handle:vertical:hover {{
                background-color: {theme['accent_hover']};
            }}
            QScrollBar:horizontal {{
                background-color: {theme['surface']};
                height: 12px;
                margin: 2px;
                border-radius: 6px;
            }}
            QScrollBar::handle:horizontal {{
                background-color: {theme['accent']};
                min-width: 20px;
                border-radius: 6px;
                margin: 2px;
            }}
            QScrollBar::handle:horizontal:hover {{
                background-color: {theme['accent_hover']};
            }}
            QTabWidget::pane {{
                border: 1px solid {theme['border']};
                background-color: {theme['bg']};
                border-radius: 6px;
            }}
            QTabBar::tab {{
                background-color: {theme['surface']};
                color: {theme['text_primary']};
                border: 1px solid {theme['border']};
                padding: 6px 12px;
                margin-right: 2px;
                border-top-left-radius: 6px;
                border-top-right-radius: 6px;
            }}
            QTabBar::tab:selected {{
                background-color: {theme['accent']};
                color: {theme['bg']};
            }}
            QTabBar::tab:hover {{
                background-color: {theme['secondary']};
                color: {theme['text_primary']};
            }}
            QDockWidget {{
                background-color: {theme['bg']};
                color: {theme['text_primary']};
                border: 1px solid {theme['border']};
                border-radius: 6px;
            }}
            QDockWidget::title {{
                background-color: {theme['bg']};
                padding: 6px;
                border: none;
            }}
            QLabel {{
                color: {theme['text_primary']};
                background-color: transparent;
            }}
            QPushButton {{
                background-color: {theme['surface']};
                color: {theme['text_primary']};
                border: 1px solid {theme['border']};
                border-radius: 6px;
                padding: 5px 10px;
            }}
            QPushButton:hover {{
                background-color: {theme['secondary']};
                color: {theme['text_primary']};
            }}
            QPushButton:pressed {{
                background-color: {theme['accent']};
                color: {theme['bg']};
            }}
            QLineEdit {{
                background-color: {theme['surface']};
                color: {theme['text_primary']};
                border: 1px solid {theme['border']};
                border-radius: 4px;
                padding: 4px 8px;
            }}
            QAbstractItemView {{
                selection-background-color: {theme['accent']};
                selection-color: {theme['bg']};
                alternate-background-color: {theme['surface']};
            }}
            QTreeView::item:!selected, QListView::item:!selected, QListWidget::item:!selected {{
                color: {theme['text_primary']};
            }}
        """

    def load_xdg_folders(self):
        self.places_list.clear()
        xdg_folders = [
            ('Home', self.get_xdg_folder('HOME'), 'user-home'),
            ('Desktop', self.get_xdg_folder('DESKTOP'), 'user-desktop'),
            ('Documents', self.get_xdg_folder('DOCUMENTS'), 'folder-documents'),
            ('Downloads', self.get_xdg_folder('DOWNLOAD'), 'folder-downloads'),
            ('Music', self.get_xdg_folder('MUSIC'), 'folder-music'),
            ('Pictures', self.get_xdg_folder('PICTURES'), 'folder-pictures'),
            ('Videos', self.get_xdg_folder('VIDEOS'), 'folder-videos'),
            ('Templates', self.get_xdg_folder('TEMPLATES'), 'folder-templates'),
            ('Public', self.get_xdg_folder('PUBLICSHARE'), 'folder-publicshare'),
            ('Trash', os.path.expanduser('~/.local/share/Trash'), 'user-trash'),
        ]
        xdg_folders.append(('File System', '/', 'drive-harddisk'))
        xdg_folders.append(('Network', '/net', 'network-workgroup'))
        
        for name, path, icon_name in xdg_folders:
            if path and os.path.exists(path) and os.path.isdir(path):
                item = QListWidgetItem(name)
                icon = QIcon.fromTheme(icon_name)
                if icon.isNull():
                    if icon_name == 'user-home':
                        icon = self.style().standardIcon(self.style().SP_DirHomeIcon)
                    elif icon_name == 'drive-harddisk':
                        icon = self.style().standardIcon(self.style().SP_DriveHDIcon)
                    elif icon_name == 'network-workgroup':
                        icon = self.style().standardIcon(self.style().SP_DriveNetIcon)
                    else:
                        icon = self.style().standardIcon(self.style().SP_DirIcon)
                item.setIcon(icon)
                item.setData(Qt.UserRole, path)
                self.places_list.addItem(item)

    def get_xdg_folder(self, folder_type):
        try:
            result = subprocess.run(['xdg-user-dir', folder_type], 
                                  capture_output=True, text=True, check=True)
            path = result.stdout.strip()
            if path and os.path.exists(path) and os.path.isdir(path):
                return path
        except (subprocess.CalledProcessError, FileNotFoundError):
            pass
            
        config_file = os.path.expanduser('~/.config/user-dirs.dirs')
        if os.path.exists(config_file):
            try:
                with open(config_file, 'r') as f:
                    for line in f:
                        if line.startswith(f'XDG_{folder_type}_DIR'):
                            path = line.split('=')[1].strip().strip('"')
                            path = path.replace('$HOME', os.path.expanduser('~'))
                            if os.path.exists(path) and os.path.isdir(path):
                                return path
            except Exception:
                pass
                
        fallback_paths = {
            'HOME': os.path.expanduser('~'),
            'DESKTOP': os.path.expanduser('~/Desktop'),
            'DOCUMENTS': os.path.expanduser('~/Documents'),
            'DOWNLOAD': os.path.expanduser('~/Downloads'),
            'MUSIC': os.path.expanduser('~/Music'),
            'PICTURES': os.path.expanduser('~/Pictures'),
            'VIDEOS': os.path.expanduser('~/Videos'),
            'TEMPLATES': os.path.expanduser('~/Templates'),
            'PUBLICSHARE': os.path.expanduser('~/Public'),
        }
        return fallback_paths.get(folder_type, os.path.expanduser('~'))

    def update_location_combo(self):
        current_text = self.location_combo.currentText()
        self.location_combo.clear()
        self.location_combo.addItem(self.current_path)
        
        common_paths = [
            self.get_xdg_folder('HOME'),
            self.get_xdg_folder('DESKTOP'),
            self.get_xdg_folder('DOCUMENTS'),
            self.get_xdg_folder('DOWNLOAD'),
            self.get_xdg_folder('MUSIC'),
            self.get_xdg_folder('PICTURES'),
            self.get_xdg_folder('VIDEOS'),
            '/',
            '/tmp'
        ]
        
        for path in common_paths:
            if path != self.current_path and path and os.path.exists(path) and os.path.isdir(path):
                self.location_combo.addItem(path)
                
        self.location_combo.setEditText(self.current_path)

    def tree_view_clicked(self, index):
        path = self.tree_model.filePath(index)
        if os.path.isdir(path):
            self.navigate_to_path(path)

    def places_item_double_clicked(self, item):
        path = item.data(Qt.UserRole)
        if os.path.exists(path) and os.path.isdir(path):
            self.navigate_to_path(path)

    def navigate_to_path(self, path):
        if not path or not os.path.exists(path) or not os.path.isdir(path):
            path = QDir.homePath()
            
        path = os.path.abspath(path)
        self.current_path = path
        
        current_tab = self.tab_widget.currentWidget()
        if current_tab:
            current_tab.navigate_to_path(path)
            index = self.tab_widget.currentIndex()
            tab_name = os.path.basename(path) or path
            self.tab_widget.setTabText(index, tab_name)
            
        tree_index = self.tree_model.index(path)
        if tree_index.isValid():
            self.tree_view.setExpanded(tree_index, True)
            self.tree_view.setCurrentIndex(tree_index)
            
        self.setWindowTitle(f"Eco File Manager - {path}")
        self.update_location_combo()
        self.location_combo.setEditText(path)
        self.update_status_bar()

    def location_combo_activated(self, index):
        if index >= 0:
            path = self.location_combo.itemText(index)
            if os.path.exists(path) and os.path.isdir(path):
                self.navigate_to_path(path)

    def location_bar_return_pressed(self):
        path = self.location_combo.currentText()
        if os.path.exists(path) and os.path.isdir(path):
            self.navigate_to_path(path)
        else:
            QMessageBox.warning(self, "Path Not Found", f"The path '{path}' does not exist or is not a directory.")
            self.update_location_combo()

    def go_back(self):
        current_tab = self.tab_widget.currentWidget()
        if current_tab:
            current_tab.go_back()
            self.current_path = current_tab.current_path
            self.update_location_combo()
            self.setWindowTitle(f"Eco File Manager - {self.current_path}")

    def go_forward(self):
        current_tab = self.tab_widget.currentWidget()
        if current_tab:
            current_tab.go_forward()
            self.current_path = current_tab.current_path
            self.update_location_combo()
            self.setWindowTitle(f"Eco File Manager - {self.current_path}")

    def go_up(self):
        current_tab = self.tab_widget.currentWidget()
        if current_tab:
            current_tab.go_up()
            self.current_path = current_tab.current_path
            self.update_location_combo()
            self.setWindowTitle(f"Eco File Manager - {self.current_path}")

    def go_home(self):
        self.navigate_to_path(self.get_xdg_folder('HOME'))

    def refresh(self):
        current_tab = self.tab_widget.currentWidget()
        if current_tab:
            current_tab.refresh()
            
        self.tree_model.setRootPath("")
        self.tree_model.setRootPath(self.current_path)
        
        self.devices_pane.refresh_devices()

    def update_status_bar(self):
        current_tab = self.tab_widget.currentWidget()
        if current_tab:
            current_tab.update_status_bar()

    def open_in_new_tab(self, path=None):
        if path is None:
            current_tab = self.tab_widget.currentWidget()
            if current_tab:
                indexes = current_tab.tree_view.selectedIndexes()
                if indexes:
                    path = current_tab.list_model.filePath(indexes[0])
                    if not os.path.isdir(path):
                        return
        if path and os.path.isdir(path):
            self.new_tab(path)

    def open_in_new_window(self, path=None):
        if path is None:
            current_tab = self.tab_widget.currentWidget()
            if current_tab:
                indexes = current_tab.tree_view.selectedIndexes()
                if indexes:
                    path = current_tab.list_model.filePath(indexes[0])
                    if not os.path.isdir(path):
                        return
        if path and os.path.isdir(path):
            self.new_window(path)

    def open_selected(self):
        current_tab = self.tab_widget.currentWidget()
        if current_tab:
            current_tab.open_selected()

    def cut_selected(self):
        current_tab = self.tab_widget.currentWidget()
        if current_tab:
            indexes = current_tab.tree_view.selectedIndexes()
            if indexes:
                self.clipboard_paths = [current_tab.list_model.filePath(index) for index in indexes if index.column() == 0]
                self.clipboard_operation = 'cut'
                self.cut_to_system_clipboard(self.clipboard_paths)

    def copy_selected(self):
        current_tab = self.tab_widget.currentWidget()
        if current_tab:
            indexes = current_tab.tree_view.selectedIndexes()
            if indexes:
                self.clipboard_paths = [current_tab.list_model.filePath(index) for index in indexes if index.column() == 0]
                self.clipboard_operation = 'copy'
                self.copy_to_system_clipboard(self.clipboard_paths)

    def paste_files(self):
        if not self.paste_from_system_clipboard():
            if not self.clipboard_paths:
                return
            current_tab = self.tab_widget.currentWidget()
            if current_tab:
                if self.clipboard_operation == 'copy':
                    self.copy_files(self.clipboard_paths, current_tab.current_path)
                elif self.clipboard_operation == 'cut':
                    self.move_files(self.clipboard_paths, current_tab.current_path)
                self.clipboard_paths = []
                self.clipboard_operation = None

    def copy_files(self, source_paths, destination_dir):
        self.start_file_operation('copy', source_paths, destination_dir)

    def move_files(self, source_paths, destination_dir):
        print(f"\n=== DEBUG move_files ===")
        print(f"destination_dir='{destination_dir}'")
        print(f"source_paths={source_paths}")
        
        valid_paths = []
        for path in source_paths:
            if os.path.exists(path):
                valid_paths.append(path)
            else:
                print(f"Warning: Source path does not exist: {path}")
        
        if not valid_paths:
            print(f"ERROR: No valid files to move")
            QMessageBox.warning(self, "No Valid Files", "No valid files to move.")
            return
        
        print(f"Starting file operation with {len(valid_paths)} files")
        self.start_file_operation('move', valid_paths, destination_dir)

    def start_file_operation(self, operation_type, source_paths, destination_dir):
        self.progress_dialog = EnhancedProgressDialog(f"{operation_type.capitalize()} Files", self)
        self.progress_dialog.show()
        self.file_operation_thread = FileOperationThread(operation_type, source_paths, destination_dir)
        self.file_operation_thread.progress.connect(self.progress_dialog.update_progress)
        self.file_operation_thread.message.connect(lambda msg: self.progress_dialog.update_progress(
            self.progress_dialog.progress_bar.value(), operation_text=msg))
        self.file_operation_thread.finished_success.connect(self.on_file_operation_success)
        self.file_operation_thread.error_occurred.connect(self.on_file_operation_error)
        self.file_operation_thread.cancelled_signal.connect(self.on_file_operation_cancelled)
        self.file_operation_thread.finished.connect(self.progress_dialog.accept)
        self.progress_dialog.rejected.connect(self.file_operation_thread.cancel)
        
        self.thread_monitor.register_thread(self.file_operation_thread, f"FileOperation_{operation_type}")
        self.file_operation_thread.start()

    def on_file_operation_success(self):
        self.refresh()
        QMessageBox.information(self, "Success", "File operation completed successfully.")
        self.thread_monitor.unregister_thread(self.file_operation_thread)

    def on_file_operation_error(self, error_msg):
        QMessageBox.critical(self, "Error", f"File operation failed: {error_msg}")
        self.thread_monitor.unregister_thread(self.file_operation_thread)

    def on_file_operation_cancelled(self):
        QMessageBox.information(self, "Cancelled", "File operation was cancelled.")
        self.thread_monitor.unregister_thread(self.file_operation_thread)
        
    def handle_file_drop(self, file_paths, destination_dir, operation):
        if not file_paths:
            return

        destination_abs = os.path.abspath(destination_dir)
        if not os.path.isdir(destination_abs):
            QMessageBox.warning(self, "Invalid Destination", "Destination is not a valid directory.")
            return

        filtered_paths = []
        for src in file_paths:
            if not os.path.exists(src):
                continue
            src_abs = os.path.abspath(src)
            dest_path = os.path.join(destination_abs, os.path.basename(src_abs))

            if operation == 'move' and src_abs == os.path.abspath(dest_path):
                print(f"Skipped self-move: {src}")
                continue

            if operation == 'move' and os.path.isdir(src_abs):
                src_norm = os.path.normpath(src_abs)
                dest_norm = os.path.normpath(destination_abs)
                if dest_norm.startswith(src_norm + os.sep):
                    QMessageBox.warning(
                        self,
                        "Invalid Move",
                        f"Cannot move '{os.path.basename(src)}' into itself."
                    )
                    continue

            filtered_paths.append(src)

        if not filtered_paths:
            QMessageBox.information(self, "Move Skipped", "All selected items were skipped (e.g., self-moves).")
            return

        conflicts = []
        for src in filtered_paths:
            dest_path = os.path.join(destination_abs, os.path.basename(os.path.abspath(src)))
            if os.path.exists(dest_path):
                conflicts.append((src, dest_path))

        if conflicts:
            self.resolve_file_conflicts(conflicts, destination_abs, operation)
        else:
            if operation == 'copy':
                self.copy_files(filtered_paths, destination_abs)
            elif operation == 'move':
                self.move_files(filtered_paths, destination_abs)

    def resolve_file_conflicts(self, conflicts, destination_dir, operation):
        global_decision = None
        apply_to_all = False
        
        for source_file, target_file in conflicts:
            if not apply_to_all:
                dialog = FileConflictDialog(source_file, target_file, self)
                if dialog.exec_() == QDialog.Accepted:
                    decision = dialog.get_decision()
                    apply_to_all = dialog.apply_to_all_conflicts()
                    
                    if apply_to_all:
                        global_decision = decision
                else:
                    return
            else:
                decision = global_decision
            
            if decision == "replace":
                try:
                    if os.path.isdir(target_file):
                        shutil.rmtree(target_file)
                    else:
                        os.remove(target_file)
                except Exception as e:
                    QMessageBox.warning(self, "Error", f"Could not replace {target_file}: {str(e)}")
                    continue
                    
            elif decision == "rename":
                base, ext = os.path.splitext(target_file)
                counter = 1
                new_target = f"{base} ({counter}){ext}"
                while os.path.exists(new_target):
                    counter += 1
                    new_target = f"{base} ({counter}){ext}"
                target_file = new_target
                
            elif decision == "skip":
                continue
            
            if operation == 'copy':
                try:
                    if os.path.isdir(source_file):
                        shutil.copytree(source_file, target_file)
                    else:
                        shutil.copy2(source_file, target_file)
                except Exception as e:
                    QMessageBox.warning(self, "Error", f"Could not copy {source_file}: {str(e)}")
            elif operation == 'move':
                try:
                    shutil.move(source_file, target_file)
                except Exception as e:
                    QMessageBox.warning(self, "Error", f"Could not move {source_file}: {str(e)}")
        
        self.refresh()

    def new_folder(self):
        current_tab = self.tab_widget.currentWidget()
        if not current_tab:
            return
        name, ok = QInputDialog.getText(self, "New Folder", "Folder name:")
        if ok and name:
            folder_path = os.path.join(current_tab.current_path, name)
            try:
                os.makedirs(folder_path, exist_ok=False)
                self.refresh()
            except FileExistsError:
                QMessageBox.warning(self, "Error", "A folder with this name already exists.")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Could not create folder: {str(e)}")

    def new_file(self):
        current_tab = self.tab_widget.currentWidget()
        if not current_tab:
            return
        name, ok = QInputDialog.getText(self, "New File", "File name:")
        if ok and name:
            file_path = os.path.join(current_tab.current_path, name)
            try:
                with open(file_path, 'w') as f:
                    pass
                self.refresh()
            except FileExistsError:
                QMessageBox.warning(self, "Error", "A file with this name already exists.")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Could not create file: {str(e)}")

    def rename_selected(self):
        current_tab = self.tab_widget.currentWidget()
        if not current_tab:
            return
        indexes = current_tab.tree_view.selectedIndexes()
        if indexes:
            path = current_tab.list_model.filePath(indexes[0])
            old_name = os.path.basename(path)
            new_name, ok = QInputDialog.getText(self, "Rename", "New name:", text=old_name)
            if ok and new_name and new_name != old_name:
                new_path = os.path.join(os.path.dirname(path), new_name)
                try:
                    os.rename(path, new_path)
                    self.refresh()
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"Could not rename: {str(e)}")

    def delete_selected(self):
        current_tab = self.tab_widget.currentWidget()
        if not current_tab:
            return
        indexes = current_tab.tree_view.selectedIndexes()
        if indexes:
            reply = QMessageBox.question(self, "Confirm Delete", 
                                       f"Move {len(indexes) // 4} item(s) to trash?",
                                       QMessageBox.Yes | QMessageBox.No)
            if reply == QMessageBox.Yes:
                paths = [current_tab.list_model.filePath(index) for index in indexes if index.column() == 0]
                self.move_to_trash(paths)
                self.refresh()

    def permanent_delete(self):
        current_tab = self.tab_widget.currentWidget()
        if not current_tab:
            return
        
        indexes = current_tab.tree_view.selectionModel().selectedRows(0)
        if not indexes:
            return
        
        item_count = len(indexes)
        
        total_size = 0
        for index in indexes:
            path = current_tab.list_model.filePath(index)
            if os.path.isfile(path):
                total_size += os.path.getsize(path)
        
        warning_msg = f"Permanently delete {item_count} item(s)?\nThis action cannot be undone."
        if total_size > 1024*1024:
            warning_msg += f"\nTotal size: {total_size/(1024*1024):.1f} MB"
        
        reply = QMessageBox.question(
            self,
            "Confirm Permanent Delete", 
            warning_msg,
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply != QMessageBox.Yes:
            return
        
        failed_deletions = []
        successful_count = 0
        
        if item_count > 10:
            progress = QProgressDialog("Deleting files...", "Cancel", 0, item_count, self)
            progress.setWindowTitle("Deleting Files")
            progress.setWindowModality(Qt.WindowModal)
            progress.show()
        
        for i, index in enumerate(indexes):
            if item_count > 10:
                progress.setValue(i)
                if progress.wasCanceled():
                    break
            
            path = current_tab.list_model.filePath(index)
            try:
                if not os.path.exists(path):
                    failed_deletions.append((path, "File no longer exists"))
                    continue
                    
                if os.path.isdir(path):
                    shutil.rmtree(path)
                else:
                    os.remove(path)
                successful_count += 1
            except Exception as e:
                failed_deletions.append((path, str(e)))
        
        if item_count > 10:
            progress.close()
        
        if successful_count and not failed_deletions:
            QMessageBox.information(self, "Success", 
                                  f"Successfully deleted {successful_count} item(s)")
        elif successful_count and failed_deletions:
            QMessageBox.warning(self, "Partial Success", 
                              f"Deleted {successful_count} item(s)\n"
                              f"Failed to delete {len(failed_deletions)} item(s)")
        elif failed_deletions:
            QMessageBox.critical(self, "Error", 
                               f"Failed to delete {len(failed_deletions)} item(s)")
        
        self.refresh()

    def move_to_trash(self, file_paths):
        if not file_paths:
            return
        try:
            try:
                import gi
                gi.require_version('Gio', '2.0')
                from gi.repository import Gio
                for path in file_paths:
                    file = Gio.File.new_for_path(path)
                    if file.query_exists(None):
                        file.trash(None)
                self.refresh()
                return
            except (ImportError, AttributeError, Exception):
                pass
                
            if shutil.which('trash'):
                try:
                    for path in file_paths:
                        subprocess.run(['trash', path])
                    self.refresh()
                    return
                except Exception:
                    pass
                    
            self.manual_move_to_trash(file_paths)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to move files to trash: {str(e)}")

    def manual_move_to_trash(self, file_paths):
        try:
            trash_dirs = self.get_trash_directories()
            if not trash_dirs:
                QMessageBox.critical(self, "Error", "Could not find or create trash directories")
                return False
            
            files_dir = trash_dirs['files']
            info_dir = trash_dirs['info']
            
            failed_moves = []
            successful_moves = []
            
            for file_path in file_paths:
                try:
                    if self.move_single_file_to_trash(file_path, files_dir, info_dir):
                        successful_moves.append(file_path)
                    else:
                        failed_moves.append(file_path)
                except Exception as e:
                    print(f"Error moving {file_path} to trash: {e}")
                    failed_moves.append(file_path)
            
            if successful_moves and not failed_moves:
                QMessageBox.information(self, "Success", 
                                      f"Moved {len(successful_moves)} item(s) to trash")
            elif successful_moves and failed_moves:
                QMessageBox.warning(self, "Partial Success", 
                                  f"Moved {len(successful_moves)} item(s) to trash\n"
                                  f"Failed to move {len(failed_moves)} item(s)")
            elif failed_moves:
                QMessageBox.critical(self, "Error", 
                                   f"Failed to move {len(failed_moves)} item(s) to trash")
            
            self.refresh()
            return len(failed_moves) == 0
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to move files to trash: {str(e)}")
            return False

    def move_single_file_to_trash(self, original_path, files_dir, info_dir):
        if not os.path.exists(original_path):
            raise FileNotFoundError(f"Source file does not exist: {original_path}")
        
        original_path = os.path.abspath(original_path)
        base_name = os.path.basename(original_path)
        
        trash_name = self.generate_unique_filename(files_dir, base_name)
        info_filename = f"{os.path.basename(trash_name)}.trashinfo"
        info_path = os.path.join(info_dir, info_filename)
        
        info_content = self.create_trashinfo_content(original_path)
        
        try:
            with open(info_path, 'w', encoding='utf-8') as f:
                f.write(info_content)
            
            trash_path = os.path.join(files_dir, trash_name)
            shutil.move(original_path, trash_path)
            
            return True
            
        except Exception as e:
            if os.path.exists(info_path):
                try:
                    os.remove(info_path)
                except:
                    pass
            raise e

    def create_trashinfo_content(self, original_path):
        encoded_path = urllib.parse.quote(original_path, safe='')
        deletion_date = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
        
        return f"""[Trash Info]
Path={encoded_path}
DeletionDate={deletion_date}
"""

    def generate_unique_filename(self, directory, base_name):
        name, ext = os.path.splitext(base_name)
        counter = 1
        new_name = base_name
        
        while os.path.exists(os.path.join(directory, new_name)):
            new_name = f"{name}.{counter}{ext}"
            counter += 1
            if counter > 1000:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
                new_name = f"{name}.{timestamp}{ext}"
                break
        
        return new_name

    def calculate_directory_size(self, path):
        self._cancel_size_calc = False
        total_size = 0
        try:
            for dirpath, dirnames, filenames in os.walk(path):
                if self._cancel_size_calc:
                    return 0
                for f in filenames:
                    if self._cancel_size_calc:
                        return 0
                    fp = os.path.join(dirpath, f)
                    if os.path.exists(fp):
                        total_size += os.path.getsize(fp)
                if len(filenames) > 100:
                    QApplication.processEvents()
        except (PermissionError, OSError):
            pass
        return total_size

    def cancel_operations(self):
        self._cancel_size_calc = True
        if hasattr(self, 'file_operation_thread') and self.file_operation_thread:
            self.file_operation_thread.cancel()

    def format_size(self, size):
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024.0:
                return f"{size:.1f} {unit}"
            size /= 1024.0
        return f"{size:.1f} PB"

    def show_properties(self):
        current_tab = self.tab_widget.currentWidget()
        if not current_tab:
            path = self.current_path
        else:
            indexes = current_tab.tree_view.selectedIndexes()
            if not indexes:
                path = current_tab.current_path
            else:
                path = current_tab.list_model.filePath(indexes[0])
                
        dialog = QDialog(self)
        dialog.setWindowTitle("Properties")
        dialog.resize(400, 300)
        layout = QFormLayout(dialog)
        
        name = os.path.basename(path)
        layout.addRow("Name:", QLabel(name))
        
        if os.path.isdir(path):
            file_type = "Directory"
        else:
            ext = os.path.splitext(path)[1]
            file_type = f"File ({ext})" if ext else "File"
        layout.addRow("Type:", QLabel(file_type))
        
        if os.path.isdir(path):
            size = self.calculate_directory_size(path)
            size_text = self.format_size(size)
        else:
            size = os.path.getsize(path)
            size_text = self.format_size(size)
        layout.addRow("Size:", QLabel(size_text))
        
        layout.addRow("Path:", QLabel(path))
        
        mtime = os.path.getmtime(path)
        mtime_str = datetime.fromtimestamp(mtime).strftime("%Y-%m-%d %H:%M:%S")
        layout.addRow("Modified:", QLabel(mtime_str))
        
        if os.path.isfile(path):
            try:
                file_stat = os.stat(path)
                permissions = oct(file_stat.st_mode)[-3:]
                layout.addRow("Permissions:", QLabel(permissions))
                
                if self.is_file_executable(path):
                    layout.addRow("Executable:", QLabel("Yes"))
                else:
                    layout.addRow("Executable:", QLabel("No"))
            except:
                pass
                
        buttons = QDialogButtonBox(QDialogButtonBox.Close)
        buttons.rejected.connect(dialog.reject)
        layout.addRow(buttons)
        dialog.exec_()

    def select_all(self):
        current_tab = self.tab_widget.currentWidget()
        if current_tab:
            current_tab.tree_view.selectAll()

    def select_none(self):
        current_tab = self.tab_widget.currentWidget()
        if current_tab:
            current_tab.tree_view.clearSelection()

    def invert_selection(self):
        current_tab = self.tab_widget.currentWidget()
        if not current_tab:
            return
        model = current_tab.tree_view.model()
        selection = current_tab.tree_view.selectionModel()
        
        root_index = current_tab.tree_view.rootIndex()
        for row in range(model.rowCount(root_index)):
            index = model.index(row, 0, root_index)
            if selection.isSelected(index):
                selection.select(index, QItemSelectionModel.Deselect)
            else:
                selection.select(index, QItemSelectionModel.Select)

    def change_view_mode(self, mode):
        for i in range(self.tab_widget.count()):
            tab = self.tab_widget.widget(i)
            if tab:
                if mode == 'icons':
                    tab.tree_view.setColumnHidden(1, True)
                    tab.tree_view.setColumnHidden(2, True)
                    tab.tree_view.setColumnHidden(3, True)
                elif mode == 'list':
                    tab.tree_view.setColumnHidden(1, False)
                    tab.tree_view.setColumnHidden(2, False)
                    tab.tree_view.setColumnHidden(3, False)
                elif mode == 'compact':
                    tab.tree_view.setColumnHidden(1, False)
                    tab.tree_view.setColumnHidden(2, True)
                    tab.tree_view.setColumnHidden(3, True)
                    
        self.view_icons_action.setChecked(mode == 'icons')
        self.view_list_action.setChecked(mode == 'list')
        self.view_compact_action.setChecked(mode == 'compact')
        
        self.refresh()

    def toggle_toolbar(self):
        self.toolbar.setVisible(self.view_toolbar_action.isChecked())

    def toggle_statusbar(self):
        self.status_bar.setVisible(self.view_statusbar_action.isChecked())

    def toggle_sidebar(self):
        main_splitter = self.findChild(QSplitter)
        if main_splitter:
            sidebar = main_splitter.widget(0)
            sidebar.setVisible(self.view_sidebar_action.isChecked())

    def show_recent(self):
        QMessageBox.information(self, "Not Implemented", "Recent files functionality will be added in a future version.")

    def closeEvent(self, event):
        try:
            self.cancel_operations()
            
            if hasattr(self, 'devices_pane') and hasattr(self.devices_pane, 'usb_monitor'):
                self.devices_pane.usb_monitor.stop()
                self.devices_pane.usb_monitor.wait(3000)
                if self.devices_pane.usb_monitor.isRunning():
                    self.devices_pane.usb_monitor.terminate()
                    self.devices_pane.usb_monitor.wait(2000)
                    
            if (hasattr(self, 'devices_pane') and hasattr(self.devices_pane, 'usb_monitor') and
                hasattr(self.devices_pane.usb_monitor, 'auto_mounter')):
                self.devices_pane.usb_monitor.auto_mounter.stop()
                self.devices_pane.usb_monitor.auto_mounter.wait(3000)
                
            if hasattr(self, 'file_operation_thread') and self.file_operation_thread:
                self.file_operation_thread.cancel()
                self.file_operation_thread.wait(2000)
                
            self.thread_monitor.cleanup_stale_threads()
        except Exception as e:
            print(f"Cleanup error: {e}")
            
        self.settings_manager.save_window_state(self)
        super().closeEvent(event)


def excepthook(exc_type, exc_value, exc_traceback):
    print(f"Uncaught exception: {exc_type.__name__}: {exc_value}")
    import traceback
    traceback.print_exception(exc_type, exc_value, exc_traceback)

sys.excepthook = excepthook

def handle_url_scheme(url):
    if url.startswith('file://'):
        from urllib.parse import unquote
        path = unquote(url[7:])
        return path
    return None

if __name__ == '__main__':
    app = QApplication(sys.argv)
    
    check_mount_dependencies()
    
    app.setApplicationName("Eco File Manager")
    app.setApplicationVersion("1.0")
    app.setOrganizationName("Eco")
    
    start_path = detect_launch_intent()
    print(f"Detected launch intent: {start_path}")
    
    if not start_path:
        start_path = os.path.expanduser('~')
        print("No path detected, using home directory")
    
    print(f"Final starting path: {start_path}")
    
    window = EcoFileManager(start_path)
    window.show()
    sys.exit(app.exec_())